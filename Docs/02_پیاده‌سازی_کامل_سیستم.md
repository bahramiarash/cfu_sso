# Ù…Ø³ØªÙ†Ø¯Ø§Øª Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø³ÛŒØ³ØªÙ… BI Ø¯Ø§Ù†Ø´Ú¯Ø§Ù‡

## ðŸ“‹ ÙÙ‡Ø±Ø³Øª Ù…Ø·Ø§Ù„Ø¨

1. [Ù†ØµØ¨ Ùˆ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡](#Ù†ØµØ¨-Ùˆ-Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ-Ø§ÙˆÙ„ÛŒÙ‡)
2. [Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡](#Ø³Ø§Ø®ØªØ§Ø±-Ù¾Ø±ÙˆÚ˜Ù‡)
3. [Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§](#Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ-Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§)
4. [Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡](#Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ-Ù¾Ø§ÛŒÚ¯Ø§Ù‡-Ø¯Ø§Ø¯Ù‡)
5. [Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ API](#Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ-api)
6. [Ú©Ø¯Ù‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡](#Ú©Ø¯Ù‡Ø§ÛŒ-Ù†Ù…ÙˆÙ†Ù‡)
7. [Ù†Ú©Ø§Øª Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ](#Ù†Ú©Ø§Øª-Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ)

---

## Ù†ØµØ¨ Ùˆ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡

### Ù¾ÛŒØ´â€ŒÙ†ÛŒØ§Ø²Ù‡Ø§

```bash
# Python 3.8+
python --version

# pip
pip --version

# Git (Ø¨Ø±Ø§ÛŒ clone Ú©Ø±Ø¯Ù† Ù¾Ø±ÙˆÚ˜Ù‡)
git --version
```

### Ù†ØµØ¨ Dependencies

```bash
# Ø§ÛŒØ¬Ø§Ø¯ Virtual Environment
python -m venv myenv

# ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Virtual Environment
# Windows:
myenv\Scripts\activate
# Linux/Mac:
source myenv/bin/activate

# Ù†ØµØ¨ Ù¾Ú©ÛŒØ¬â€ŒÙ‡Ø§
pip install -r requirements.txt
```

### ØªÙ†Ø¸ÛŒÙ…Ø§Øª Environment Variables

Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ `.env` Ø¯Ø± Ø±ÛŒØ´Ù‡ Ù¾Ø±ÙˆÚ˜Ù‡:

```env
# Secret Key (ØªÙˆÙ„ÛŒØ¯ Ø¨Ø§: python -c "import secrets; print(secrets.token_hex(32))")
SECRET_KEY=your-secret-key-here

# SSO Configuration
SSO_CLIENT_ID=bicfu
SSO_CLIENT_SECRET=your-sso-client-secret
SSO_AUTH_URL=https://sso.cfu.ac.ir/oauth2/authorize
SSO_TOKEN_URL=https://sso.cfu.ac.ir/oauth2/token
SSO_REDIRECT_URI=https://bi.cfu.ac.ir/authorized
SSO_SCOPE=profile email

# Admin Users (comma-separated)
ADMIN_USERS=admin1,admin2

# Database Paths (optional, defaults provided)
FACULTY_DB_PATH=app/fetch_data/faculty_data.db
ACCESS_CONTROL_DB_PATH=app/access_control.db

# Metrics Service URL (optional)
METRICS_SERVICE_URL=http://127.0.0.1:6000/metrics

# Dashboard Cache Settings (optional)
DASHBOARD_CACHE_ENABLED=true
DASHBOARD_CACHE_TTL=300
```

### Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡

```bash
# Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ø¯Ø§ÙˆÙ„
cd app
python -c "from app import app; from extensions import db; app.app_context().push(); db.create_all()"

# ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² init_db.py (Ø¨Ø±Ø§ÛŒ Ø¬Ø¯Ø§ÙˆÙ„ Ø®Ø§Øµ)
python init_db.py
```

### Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ±

```bash
# Development
python app/app.py

# ÛŒØ§ Ø¨Ø§ Flask CLI
flask run

# Production (Ø¨Ø§ Waitress)
waitress-serve --host=0.0.0.0 --port=5000 app:app
```

---

## Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡

```
cert2/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py                    # Main application
â”‚   â”œâ”€â”€ models.py                 # SQLAlchemy models
â”‚   â”œâ”€â”€ admin_models.py           # Admin panel models
â”‚   â”œâ”€â”€ extensions.py             # Flask extensions
â”‚   â”œâ”€â”€ auth_utils.py             # Authentication utilities
â”‚   â”œâ”€â”€ config.py                 # Configuration
â”‚   â”œâ”€â”€ dashboard_routes.py       # Dashboard routes
â”‚   â”œâ”€â”€ kanban.py                 # Kanban routes
â”‚   â”œâ”€â”€ tasks.py                  # Task management
â”‚   â”œâ”€â”€ label_management.py      # Label management
â”‚   â”œâ”€â”€ task_label_assignment.py # Task-label assignment
â”‚   â”œâ”€â”€ students_dashboard.py    # Students dashboard
â”‚   â”œâ”€â”€ send_sms.py               # SMS sending
â”‚   â”‚
â”‚   â”œâ”€â”€ admin/                    # Admin panel
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ routes.py            # Admin routes
â”‚   â”‚   â”œâ”€â”€ utils.py             # Admin utilities
â”‚   â”‚   â”œâ”€â”€ scheduler.py         # Auto-sync scheduler
â”‚   â”‚   â”œâ”€â”€ sync_handlers.py     # Sync handlers
â”‚   â”‚   â””â”€â”€ sync_progress.py    # Sync progress
â”‚   â”‚
â”‚   â”œâ”€â”€ dashboards/               # Dashboard system
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py              # Base dashboard class
â”‚   â”‚   â”œâ”€â”€ registry.py          # Dashboard registry
â”‚   â”‚   â”œâ”€â”€ context.py           # User context
â”‚   â”‚   â”œâ”€â”€ config.py            # Dashboard config
â”‚   â”‚   â”œâ”€â”€ cache.py             # Cache system
â”‚   â”‚   â”œâ”€â”€ utils.py             # Dashboard utilities
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ data_providers/      # Data providers
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ faculty.py
â”‚   â”‚   â”‚   â”œâ”€â”€ students.py
â”‚   â”‚   â”‚   â”œâ”€â”€ pardis.py
â”‚   â”‚   â”‚   â””â”€â”€ lms.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ visualizations/     # Visualization components
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ maps.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ dashboards/          # Dashboard implementations
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ faculty_stats.py
â”‚   â”‚   â”‚   â”œâ”€â”€ faculty_map.py
â”‚   â”‚   â”‚   â”œâ”€â”€ pardis_map.py
â”‚   â”‚   â”‚   â”œâ”€â”€ student_faculty_ratio.py
â”‚   â”‚   â”‚   â”œâ”€â”€ lms_monitoring.py
â”‚   â”‚   â”‚   â””â”€â”€ students_dashboard.py
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ api.py               # Dashboard API
â”‚   â”‚
â”‚   â”œâ”€â”€ fetch_data/               # Data fetching scripts
â”‚   â”‚   â”œâ”€â”€ faculty_main.py       # Faculty sync
â”‚   â”‚   â”œâ”€â”€ students_main.py     # Students sync
â”‚   â”‚   â”œâ”€â”€ lms_sync.py          # LMS sync
â”‚   â”‚   â”œâ”€â”€ lms.py               # LMS utilities
â”‚   â”‚   â””â”€â”€ employee.py          # Employee data
â”‚   â”‚
â”‚   â”œâ”€â”€ templates/                # Jinja2 templates
â”‚   â”‚   â”œâ”€â”€ base.html
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ dashboard_list.html
â”‚   â”‚   â”œâ”€â”€ dashboards/
â”‚   â”‚   â”‚   â”œâ”€â”€ d1.html
â”‚   â”‚   â”‚   â”œâ”€â”€ d2.html
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ admin/
â”‚   â”‚       â”œâ”€â”€ base.html
â”‚   â”‚       â”œâ”€â”€ index.html
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”‚
â”‚   â”œâ”€â”€ static/                   # Static files
â”‚   â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”œâ”€â”€ js/
â”‚   â”‚   â”œâ”€â”€ fonts/
â”‚   â”‚   â””â”€â”€ images/
â”‚   â”‚
â”‚   â”œâ”€â”€ data/                     # Data files
â”‚   â”‚   â”œâ”€â”€ iran_shapefile/
â”‚   â”‚   â””â”€â”€ province_mappings.json
â”‚   â”‚
â”‚   â”œâ”€â”€ migrations/               # Database migrations
â”‚   â”œâ”€â”€ tests/                    # Tests
â”‚   â””â”€â”€ access_control.db        # Main database
â”‚
â”œâ”€â”€ Docs/                         # Documentation
â”œâ”€â”€ requirements.txt              # Python dependencies
â”œâ”€â”€ config.py                     # Project config
â””â”€â”€ .env                          # Environment variables
```

---

## Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§

### 1. Ù…Ø§Ú˜ÙˆÙ„ Authentication

#### app/auth_utils.py

```python
from flask import session, redirect, request, url_for
from functools import wraps
import logging

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if "sso_token" not in session:
            logging.info("User not authenticated, redirecting to login")
            return redirect(url_for("login", next=request.path))
        return f(*args, **kwargs)
    return decorated
```

#### app/app.py (Authentication Routes)

```python
from authlib.integrations.flask_client import OAuth
from flask_login import login_user, LoginManager

# Initialize OAuth
oauth = OAuth(app)
oauth.register(
    name="sso",
    client_id=SSO_CONFIG["client_id"],
    client_secret=SSO_CONFIG["client_secret"],
    authorize_url=SSO_CONFIG["authorize_url"],
    access_token_url=SSO_CONFIG["access_token_url"],
    userinfo_endpoint='https://sso.cfu.ac.ir/oauth2/userinfo',
    redirect_uri=SSO_CONFIG["redirect_uri"],
    client_kwargs={'scope': SSO_CONFIG["scope"]}
)

@app.route("/login")
def login():
    redirect_uri = SSO_CONFIG["redirect_uri"]
    wants_url = request.args.get("next", url_for("index", _external=True))
    sesskey = session.setdefault("sesskey", secrets.token_urlsafe(8))
    state = quote_plus(f"https://sso.cfu.ac.ir/oauth2/login.php?wantsurl={quote_plus(wants_url)}&sesskey={sesskey}")
    session["oauth_state"] = state
    return oauth.sso.authorize_redirect(redirect_uri, state=state)

@app.route("/authorized")
def authorized():
    stored_state = session.get("oauth_state")
    returned_state = request.args.get("state")
    
    if stored_state != returned_state:
        return render_template("error.html", error="CSRF Warning!"), 400
    
    token = oauth.sso.authorize_access_token()
    session["sso_token"] = token
    userinfo = get_user_info(token)
    session["user_info"] = userinfo
    
    # Create or update user
    user = User.query.filter_by(sso_id=userinfo.get("username", "").lower()).first()
    if not user:
        user = User(sso_id=userinfo.get("username", "").lower(), 
                   name=userinfo.get("fullname", "Unnamed User"))
        db.session.add(user)
        db.session.commit()
    
    login_user(user)
    return redirect(url_for("index"))
```

### 2. Ù…Ø§Ú˜ÙˆÙ„ Dashboard System

#### Base Dashboard

```python
# app/dashboards/base.py
from abc import ABC, abstractmethod
from flask import render_template, make_response
from .context import UserContext
from .cache import DashboardCache

class BaseDashboard(ABC):
    def __init__(self, dashboard_id: str, title: str, description: str = None):
        self.dashboard_id = dashboard_id
        self.title = title
        self.description = description
        self.cache_enabled = True
        self.cache_ttl = 300
    
    @abstractmethod
    def get_data(self, context: UserContext, **kwargs) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    def render(self, data: Dict[str, Any], context: UserContext):
        pass
    
    def handle_request(self, user_context: UserContext = None, **kwargs):
        if user_context is None:
            user_context = get_user_context()
        
        if not self.check_access(user_context):
            return self.render_error("Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯", 403)
        
        filters = self._extract_filters_from_request(kwargs)
        filters = user_context.apply_filters(filters)
        
        cache_key = self._generate_cache_key(user_context, filters)
        
        if self.cache_enabled:
            cached_data = DashboardCache.get(cache_key)
            if cached_data is not None:
                return self.render(cached_data, user_context)
        
        data = self.get_data(user_context, **filters)
        
        if self.cache_enabled:
            DashboardCache.set(cache_key, data, self.cache_ttl)
        
        return self.render(data, user_context)
    
    def check_access(self, context: UserContext) -> bool:
        return True  # Override in subclasses
```

#### Dashboard Registry

```python
# app/dashboards/registry.py
class DashboardRegistry:
    _dashboards: Dict[str, BaseDashboard] = {}
    
    @classmethod
    def register(cls, dashboard_class):
        instance = dashboard_class()
        cls._dashboards[instance.dashboard_id] = instance
        return dashboard_class
    
    @classmethod
    def get(cls, dashboard_id: str) -> Optional[BaseDashboard]:
        return cls._dashboards.get(dashboard_id)
    
    @classmethod
    def get_accessible_dashboards(cls, user_context) -> List[Dict]:
        accessible = []
        for dashboard in cls._dashboards.values():
            if dashboard.check_access(user_context):
                accessible.append({
                    'dashboard_id': dashboard.dashboard_id,
                    'dashboard_title': dashboard.title,
                    'dashboard_description': dashboard.description
                })
        return accessible
```

#### Ù†Ù…ÙˆÙ†Ù‡ Dashboard Implementation

```python
# app/dashboards/dashboards/faculty_stats.py
from dashboards.base import BaseDashboard
from dashboards.registry import DashboardRegistry
from dashboards.data_providers import FacultyDataProvider
from dashboards.context import UserContext

@DashboardRegistry.register
class FacultyStatsDashboard(BaseDashboard):
    def __init__(self):
        super().__init__(
            dashboard_id="d1",
            title="Ø¢Ù…Ø§Ø± Ø¯Ø§Ù†Ø´Ú©Ø¯Ù‡â€ŒÙ‡Ø§",
            description="Ù†Ù…Ø§ÛŒØ´ Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ Ø¯Ø§Ù†Ø´Ú©Ø¯Ù‡â€ŒÙ‡Ø§"
        )
        self.data_provider = FacultyDataProvider()
    
    def get_data(self, context: UserContext, **kwargs) -> Dict[str, Any]:
        # Apply filters
        filters = {}
        if context.data_filters.get('province_code'):
            filters['province_code'] = context.data_filters['province_code']
        if context.data_filters.get('faculty_code'):
            filters['faculty_code'] = context.data_filters['faculty_code']
        
        # Query data
        query = "SELECT province_code, COUNT(*) as count FROM faculty"
        if filters:
            query += " WHERE " + " AND ".join([f"{k} = ?" for k in filters.keys()])
            params = tuple(filters.values())
        else:
            params = ()
        
        results = self.data_provider.execute_query(query, params, context)
        
        return {
            'stats': results,
            'filters': filters
        }
    
    def render(self, data: Dict[str, Any], context: UserContext):
        template_context = self.get_template_context(data, context)
        return render_template('dashboards/d1.html', **template_context)
```

### 3. Ù…Ø§Ú˜ÙˆÙ„ Data Synchronization

#### Sync Handler

```python
# app/admin/sync_handlers.py
def run_faculty_sync(user_id=None, sync_id=None):
    sync = DataSync.query.filter_by(data_source='faculty').first()
    if not sync:
        return False, 0, "Faculty sync configuration not found"
    
    try:
        sync.status = 'running'
        sync.last_synced_by = user_id
        db.session.commit()
        
        # Run fetch script
        script_path = os.path.join(FETCH_DATA_DIR, 'faculty_main.py')
        process = subprocess.Popen(
            [sys.executable, script_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        stdout, stderr = process.communicate()
        
        if process.returncode == 0:
            # Parse output for record count
            records_count = parse_record_count(stdout)
            sync.records_synced = records_count
            sync.status = 'success'
            sync.last_sync_at = datetime.utcnow()
            sync.next_sync_at = calculate_next_sync(sync)
            sync.error_message = None
            db.session.commit()
            return True, records_count, None
        else:
            sync.status = 'failed'
            sync.error_message = stderr
            db.session.commit()
            return False, 0, stderr
            
    except Exception as e:
        sync.status = 'failed'
        sync.error_message = str(e)
        db.session.commit()
        return False, 0, str(e)
```

#### Scheduler

```python
# app/admin/scheduler.py
def scheduler_loop():
    global _scheduler_running
    _scheduler_running = True
    
    while _scheduler_running:
        try:
            check_and_run_scheduled_syncs()
        except Exception as e:
            logger.error(f"Error in scheduler loop: {e}", exc_info=True)
        
        time.sleep(60)  # Check every minute

def check_and_run_scheduled_syncs():
    now = datetime.utcnow()
    due_syncs = DataSync.query.filter(
        DataSync.auto_sync_enabled == True,
        DataSync.status != 'running',
        DataSync.next_sync_at <= now
    ).all()
    
    for sync in due_syncs:
        thread = threading.Thread(
            target=run_sync_background,
            args=(sync.id, sync.data_source),
            daemon=True
        )
        thread.start()
```

### 4. Ù…Ø§Ú˜ÙˆÙ„ Cache

```python
# app/dashboards/cache.py
class DashboardCache:
    _cache: dict = {}
    _ttl: dict = {}
    
    @classmethod
    def get(cls, key: str) -> Optional[Any]:
        if key in cls._cache:
            if datetime.now() < cls._ttl.get(key, datetime.min):
                return cls._cache[key]
            else:
                del cls._cache[key]
                del cls._ttl[key]
        return None
    
    @classmethod
    def set(cls, key: str, value: Any, ttl: int = 300):
        cls._cache[key] = value
        cls._ttl[key] = datetime.now() + timedelta(seconds=ttl)
    
    @classmethod
    def generate_key(cls, prefix: str, **kwargs) -> str:
        key_str = f"{prefix}:{json.dumps(kwargs, sort_keys=True)}"
        key_hash = hashlib.md5(key_str.encode()).hexdigest()
        return f"{prefix}:{key_hash}"
```

---

## Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡

### Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ø¨Ø§ SQLAlchemy

```python
# app/models.py
from extensions import db
from flask_login import UserMixin

class User(db.Model, UserMixin):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    email = db.Column(db.String, unique=True)
    sso_id = db.Column(db.String, nullable=False, unique=True)
    province_code = db.Column(db.Integer, nullable=True)
    university_code = db.Column(db.Integer, nullable=True)
    faculty_code = db.Column(db.Integer, nullable=True)
    
    access_levels = db.relationship('AccessLevel', backref='user', lazy=True)
    projects_created = db.relationship('Project', foreign_keys='Project.creator_id', back_populates='creator')

# Create tables
with app.app_context():
    db.create_all()
```

### Migration Script

```python
# app/migrations/create_admin_tables.py
from extensions import db
from admin_models import DashboardAccess, AccessLog, DataSync, DashboardConfig

def migrate():
    with app.app_context():
        db.create_all()
        print("Admin tables created successfully")
```

---

## Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ API

### Dashboard API

```python
# app/dashboards/api.py
from flask import Blueprint, jsonify, request
from dashboards.registry import DashboardRegistry
from dashboards.context import get_user_context

api_bp = Blueprint("dashboard_api", __name__, url_prefix="/api/dashboard")

@api_bp.route("/<dashboard_id>/data")
def get_dashboard_data(dashboard_id):
    dashboard = DashboardRegistry.get(dashboard_id)
    if not dashboard:
        return jsonify({"error": "Dashboard not found"}), 404
    
    user_context = get_user_context()
    if not dashboard.check_access(user_context):
        return jsonify({"error": "Access denied"}), 403
    
    filters = {
        'province_code': request.args.get('province_code', type=int),
        'faculty_code': request.args.get('faculty_code', type=int),
        'date_from': request.args.get('date_from'),
        'date_to': request.args.get('date_to')
    }
    
    filters = user_context.apply_filters(filters)
    data = dashboard.get_data(user_context, **filters)
    
    return jsonify(data)
```

---

## Ú©Ø¯Ù‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡

### Ù†Ù…ÙˆÙ†Ù‡: Ø§ÛŒØ¬Ø§Ø¯ Dashboard Ø¬Ø¯ÛŒØ¯

```python
# app/dashboards/dashboards/my_dashboard.py
from dashboards.base import BaseDashboard
from dashboards.registry import DashboardRegistry
from dashboards.data_providers import FacultyDataProvider
from flask import render_template

@DashboardRegistry.register
class MyDashboard(BaseDashboard):
    def __init__(self):
        super().__init__(
            dashboard_id="my_dashboard",
            title="Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ù†",
            description="ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯"
        )
        self.data_provider = FacultyDataProvider()
    
    def get_data(self, context, **kwargs):
        # Fetch and process data
        query = "SELECT * FROM faculty LIMIT 100"
        results = self.data_provider.execute_query_dict(query, (), context)
        return {'data': results}
    
    def render(self, data, context):
        template_context = self.get_template_context(data, context)
        return render_template('dashboards/my_dashboard.html', **template_context)
```

### Ù†Ù…ÙˆÙ†Ù‡: Ø§ÛŒØ¬Ø§Ø¯ Data Provider Ø¬Ø¯ÛŒØ¯

```python
# app/dashboards/data_providers/my_provider.py
from .base import DataProvider
from dashboards.config import DashboardConfig

class MyDataProvider(DataProvider):
    def get_default_db_path(self) -> str:
        return DashboardConfig.FACULTY_DB
    
    def get_my_data(self, context=None):
        query = "SELECT * FROM my_table"
        return self.execute_query_dict(query, (), context)
```

---

## Ù†Ú©Ø§Øª Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ

### 1. Error Handling

```python
try:
    # Code
except SpecificError as e:
    logger.error(f"Error: {e}", exc_info=True)
    return render_template("error.html", error=str(e)), 500
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    return render_template("error.html", error="Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡"), 500
```

### 2. Logging

```python
import logging

logger = logging.getLogger(__name__)

logger.info("Info message")
logger.warning("Warning message")
logger.error("Error message", exc_info=True)
```

### 3. Database Transactions

```python
try:
    # Database operations
    db.session.add(new_record)
    db.session.commit()
except Exception as e:
    db.session.rollback()
    logger.error(f"Database error: {e}")
    raise
```

### 4. Thread Safety

```python
import threading

_lock = threading.Lock()

def thread_safe_function():
    with _lock:
        # Critical section
        pass
```

---

## Ù†ØªÛŒØ¬Ù‡â€ŒÚ¯ÛŒØ±ÛŒ

Ø§ÛŒÙ† Ù…Ø³ØªÙ†Ø¯ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ú©Ø§Ù…Ù„ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ… Ø§Ø³Øª. Ø¨Ø§ Ø¯Ù†Ø¨Ø§Ù„ Ú©Ø±Ø¯Ù† Ø§ÛŒÙ† Ø±Ø§Ù‡Ù†Ù…Ø§ØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø³ÛŒØ³ØªÙ… Ø±Ø§ Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯.

---

**ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯**: 1404/01/15
**Ù†Ø³Ø®Ù‡**: 1.0.0
**Ù†Ú¯Ù‡Ø¯Ø§Ø±Ù†Ø¯Ù‡**: ØªÛŒÙ… ØªÙˆØ³Ø¹Ù‡




