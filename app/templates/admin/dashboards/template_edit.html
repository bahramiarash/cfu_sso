{% extends "admin/base.html" %}

{% block title %}ویرایش تمپلیت: {{ template_name }}{% endblock %}

{% block extra_css %}
<!-- CodeMirror CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
<style>
    .CodeMirror {
        border: 1px solid #ddd;
        border-radius: 4px;
        height: 600px;
        font-size: 14px;
        direction: ltr;
        text-align: left;
    }
    .template-info {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 20px;
    }
    .save-status {
        display: none;
        margin-top: 10px;
    }
    /* Search Box Styles */
    .search-box-container {
        display: none;
        margin-bottom: 15px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #dee2e6;
    }
    .search-box-container.active {
        display: block;
    }
    .search-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
    }
    .search-input-group {
        flex: 1;
        min-width: 250px;
        display: flex;
        gap: 5px;
    }
    .search-input-group input {
        flex: 1;
    }
    .search-options {
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
    }
    .search-options label {
        margin: 0;
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
    }
    .search-results {
        margin-top: 10px;
        font-size: 12px;
        color: #6c757d;
    }
    .CodeMirror-search-match {
        background: rgba(255, 235, 59, 0.4);
        border-top: 1px solid rgba(255, 235, 59, 0.8);
        border-bottom: 1px solid rgba(255, 235, 59, 0.8);
    }
    .CodeMirror-search-match.CodeMirror-search-match-selected {
        background: rgba(255, 193, 7, 0.6);
        border-top: 1px solid rgba(255, 193, 7, 1);
        border-bottom: 1px solid rgba(255, 193, 7, 1);
    }
    /* Visual Editor Styles */
    .chart-item {
        background: #fff;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        cursor: move;
        transition: all 0.3s ease;
        position: relative;
    }
    .chart-item:hover {
        border-color: #0d6efd;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .chart-item.dragging {
        opacity: 0.5;
        border-color: #0d6efd;
    }
    .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    .chart-title-input {
        flex: 1;
        margin-left: 10px;
        font-weight: bold;
    }
    .chart-order-badge {
        background: #0d6efd;
        color: white;
        padding: 5px 10px;
        border-radius: 20px;
        font-size: 12px;
        min-width: 40px;
        text-align: center;
    }
    .chart-content-wrapper {
        display: flex;
        flex-direction: row-reverse; /* RTL: right-to-left layout */
        gap: 20px;
        margin-top: 15px;
    }
    .chart-preview {
        background: #f8f9fa;
        border: 1px dashed #dee2e6;
        border-radius: 4px;
        padding: 20px;
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 1; /* Take remaining space */
    }
    .chart-preview canvas {
        max-width: 100%;
        max-height: 300px;
    }
    .element-settings {
        flex: 0 0 150px; /* Fixed width for settings (half of original) */
        min-width: 140px;
    }
    .chart-settings {
        display: grid;
        grid-template-columns: 1fr;
        gap: 15px;
    }
    @media (max-width: 768px) {
        .chart-content-wrapper {
            flex-direction: column;
        }
        .element-settings {
            flex: 1;
            min-width: auto;
        }
    }
    .chart-setting-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    .chart-setting-item label {
        font-size: 0.9rem;
        margin-bottom: 0;
    }
    .chart-setting-item .form-label {
        font-weight: 500;
        font-size: 0.85rem;
        margin-bottom: 4px;
    }
    .chart-type-select {
        width: 100%;
    }
    .sortable-ghost {
        opacity: 0.4;
    }
    .chart-type-icon {
        font-size: 1.2rem;
        color: #0d6efd;
        display: inline-flex;
        align-items: center;
        flex-shrink: 0;
    }
    .element-title-wrapper {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1><i class="bi bi-file-code"></i> ویرایش تمپلیت: <code>{{ template_name }}</code></h1>
        <a href="{{ url_for('admin.dashboard_templates_list') }}" class="btn btn-secondary">
            <i class="bi bi-arrow-right"></i> بازگشت به لیست
        </a>
    </div>

    {% if dashboard %}
    <div class="template-info">
        <h5><i class="bi bi-info-circle"></i> اطلاعات داشبورد</h5>
        <p class="mb-1"><strong>عنوان:</strong> {{ dashboard.title }}</p>
        {% if dashboard.description %}
        <p class="mb-0"><strong>توضیحات:</strong> {{ dashboard.description }}</p>
        {% endif %}
    </div>
    {% endif %}

    <!-- ویرایشگر HTML در ابتدای صفحه -->
    <div class="card mb-4">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0"><i class="bi bi-code-slash"></i> ویرایشگر کد HTML</h5>
            <div>
                <button type="button" class="btn btn-sm btn-secondary" onclick="toggleSearch()" id="searchToggleBtn">
                    <i class="bi bi-search"></i> جستجو
                </button>
                <button type="button" class="btn btn-sm btn-warning" onclick="validateCode()">
                    <i class="bi bi-shield-check"></i> کنترل کدهای داشبورد
                </button>
                <button type="button" class="btn btn-sm btn-info" onclick="previewTemplate()">
                    <i class="bi bi-eye"></i> پیش‌نمایش
                </button>
                <button type="button" class="btn btn-sm btn-success" onclick="saveTemplate()">
                    <i class="bi bi-save"></i> ذخیره
                </button>
            </div>
        </div>
        <div class="card-body">
            <form id="templateForm">
                <!-- Search Box -->
                <div class="search-box-container" id="searchBox">
                    <div class="search-controls">
                        <div class="search-input-group">
                            <input type="text" 
                                   id="searchInput" 
                                   class="form-control form-control-sm" 
                                   placeholder="جستجو در کد..."
                                   autocomplete="off">
                            <button type="button" class="btn btn-sm btn-primary" onclick="doSearch()">
                                <i class="bi bi-search"></i>
                            </button>
                            <button type="button" class="btn btn-sm btn-secondary" onclick="findNext()">
                                <i class="bi bi-arrow-down"></i> بعدی
                            </button>
                            <button type="button" class="btn btn-sm btn-secondary" onclick="findPrevious()">
                                <i class="bi bi-arrow-up"></i> قبلی
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearSearch()">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                        <div class="search-options">
                            <label>
                                <input type="checkbox" id="caseSensitive" onchange="doSearch()">
                                حساس به حروف بزرگ/کوچک
                            </label>
                            <label>
                                <input type="checkbox" id="useRegex" onchange="doSearch()">
                                استفاده از Regex
                            </label>
                        </div>
                    </div>
                    <div class="search-results" id="searchResults"></div>
                </div>
                <div class="mb-3">
                    <textarea id="templateContent" name="content">{{ content }}</textarea>
                </div>
                <div class="save-status alert" id="saveStatus"></div>
            </form>
        </div>
        <div class="card-footer">
            <small class="text-muted">
                <i class="bi bi-info-circle"></i>
                قبل از ذخیره، یک نسخه پشتیبان (.backup) از فایل فعلی ایجاد می‌شود.
                اندازه فایل: {% if file_size %}{{ "%.2f"|format(file_size / 1024.0) }} KB{% else %}نامشخص{% endif %}
                {% if modified_time %}
                | آخرین تغییر: {{ modified_time.strftime('%Y/%m/%d %H:%M') }}
                {% endif %}
            </small>
        </div>
    </div>

    <!-- فهرست نمودارها -->
    {% if charts_list and charts_list|length > 0 %}
    <div class="card mt-4">
        <div class="card-header">
            <h5 class="mb-0"><i class="bi bi-list-ul"></i> فهرست نمودارهای تمپلیت</h5>
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-striped table-hover table-bordered">
                    <thead class="table-dark">
                        <tr>
                            <th style="width: 50px;">ردیف</th>
                            <th>عنوان فارسی</th>
                            <th>ID نمودار</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for chart in charts_list %}
                        <tr>
                            <td class="text-center">{{ loop.index }}</td>
                            <td>{{ chart.title }}</td>
                            <td><code>{{ chart.chart_id }}</code></td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            <div class="alert alert-info mt-3 mb-0">
                <i class="bi bi-info-circle"></i> 
                <strong>توجه:</strong> این جدول فهرست تمام نمودارهای موجود در تمپلیت را نمایش می‌دهد. 
                برای ویرایش تنظیمات هر نمودار، از بخش "طراحی گرافیک تمپلیت" استفاده کنید.
            </div>
        </div>
    </div>
    {% endif %}

    <!-- طراحی گرافیک تمپلیت -->
    <div class="card mt-4" id="visual-editor">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0"><i class="bi bi-palette"></i> طراحی گرافیک تمپلیت</h5>
            <div>
                <button type="button" class="btn btn-sm btn-primary" onclick="loadVisualElements()">
                    <i class="bi bi-arrow-clockwise"></i> بارگذاری مجدد
                </button>
                <button type="button" class="btn btn-sm btn-success" onclick="saveAllSettings(event)">
                    <i class="bi bi-save"></i> ذخیره همه تنظیمات
                </button>
                <button type="button" class="btn btn-sm btn-info" onclick="showVersions()">
                    <i class="bi bi-clock-history"></i> نسخه‌های قبلی
                </button>
            </div>
        </div>
        <div class="card-body">
            <!-- Status message for save operation -->
            <div class="save-status alert" id="chartSaveStatus" style="display: none; margin-bottom: 1rem;"></div>
            <div id="visualElementsContainer">
                <div class="text-center py-5">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">در حال بارگذاری...</span>
                    </div>
                    <p class="mt-3">در حال بارگذاری نمودارها و جداول...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal for Code Validation Results -->
<div class="modal fade" id="validationModal" tabindex="-1" aria-labelledby="validationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="validationModalLabel">
                    <i class="bi bi-shield-check"></i> نتایج کنترل کدهای داشبورد
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="validationResults">
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">در حال بررسی...</span>
                        </div>
                        <p class="mt-3">در حال بررسی کدها...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="bi bi-x-circle"></i> بستن
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modal for Chart Diff Preview -->
<div class="modal fade" id="chartDiffModal" tabindex="-1" aria-labelledby="chartDiffModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="chartDiffModalLabel">
                    <i class="bi bi-code-square"></i> پیش‌نمایش تغییرات نمودار
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6 class="text-danger mb-3">
                            <i class="bi bi-file-earmark-minus"></i> کد قبل از تغییر
                        </h6>
                        <pre id="diffBeforeCode" class="bg-light p-3 rounded" style="max-height: 500px; overflow-y: auto; direction: ltr; text-align: left; font-size: 12px;"></pre>
                    </div>
                    <div class="col-md-6">
                        <h6 class="text-success mb-3">
                            <i class="bi bi-file-earmark-plus"></i> کد بعد از تغییر
                        </h6>
                        <pre id="diffAfterCode" class="bg-light p-3 rounded" style="max-height: 500px; overflow-y: auto; direction: ltr; text-align: left; font-size: 12px;"></pre>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="bi bi-x-circle"></i> انصراف
                </button>
                <button type="button" class="btn btn-primary" id="confirmSaveChartBtn" onclick="confirmSaveSingleChart()">
                    <i class="bi bi-check-circle"></i> تایید و ذخیره
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- CodeMirror JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
<!-- CodeMirror Search Addon -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/search/search.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/search/searchcursor.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/dialog/dialog.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/dialog/dialog.min.js"></script>
<!-- SortableJS for Drag & Drop -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
<!-- Chart.js for preview -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@latest/dist/chart.umd.js"></script>

<script>
    // Initialize CodeMirror
    const editor = CodeMirror.fromTextArea(document.getElementById('templateContent'), {
        mode: 'htmlmixed',
        theme: 'monokai',
        lineNumbers: true,
        lineWrapping: true,
        indentUnit: 4,
        indentWithTabs: false,
        autoCloseTags: true,
        matchTags: true,
        autoCloseBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {
            "Ctrl-F": function(cm) {
                toggleSearch();
                setTimeout(() => document.getElementById('searchInput').focus(), 100);
            },
            "F3": function(cm) {
                findNext();
            },
            "Shift-F3": function(cm) {
                findPrevious();
            }
        }
    });

    // Search functionality
    let searchState = {
        query: null,
        cursor: null,
        matches: [],
        currentMatchIndex: -1
    };

    function toggleSearch() {
        const searchBox = document.getElementById('searchBox');
        const isActive = searchBox.classList.contains('active');
        
        if (isActive) {
            searchBox.classList.remove('active');
            clearSearch();
        } else {
            searchBox.classList.add('active');
            setTimeout(() => document.getElementById('searchInput').focus(), 100);
        }
    }

    function doSearch() {
        const query = document.getElementById('searchInput').value;
        if (!query) {
            clearSearch();
            return;
        }

        const caseSensitive = document.getElementById('caseSensitive').checked;
        const useRegex = document.getElementById('useRegex').checked;

        searchState.query = query;
        
        // Clear previous search
        editor.operation(function() {
            for (let i = 0; i < searchState.matches.length; i++) {
                const match = searchState.matches[i];
                if (match.line !== undefined) {
                    editor.removeLineClass(match.line, "background", "CodeMirror-search-match");
                    editor.removeLineClass(match.line, "background", "CodeMirror-search-match-selected");
                }
            }
        });

        searchState.matches = [];
        searchState.currentMatchIndex = -1;
        
        if (!useRegex) {
            // Simple text search
            try {
                const searchCursor = editor.getSearchCursor(
                    query, 
                    {line: 0, ch: 0}, 
                    !caseSensitive
                );
                
                let matchCount = 0;
                while (searchCursor.findNext()) {
                    matchCount++;
                    const from = searchCursor.from();
                    const to = searchCursor.to();
                    
                    // Store match info
                    searchState.matches.push({
                        from: from,
                        to: to,
                        line: from.line
                    });
                    
                    // Mark the line
                    editor.addLineClass(from.line, "background", "CodeMirror-search-match");
                    
                    // Set cursor to first match
                    if (matchCount === 1) {
                        editor.setCursor(from);
                        editor.scrollIntoView(from, 100);
                        searchState.currentMatchIndex = 0;
                        highlightCurrentMatch(0);
                    }
                }
                
                updateSearchResults(matchCount);
                
                if (matchCount > 0) {
                    searchState.cursor = editor.getSearchCursor(
                        query,
                        editor.getCursor(),
                        !caseSensitive
                    );
                }
            } catch (e) {
                updateSearchResults(0, 'خطا در جستجو: ' + e.message);
            }
        } else {
            // Regex search
            try {
                const flags = caseSensitive ? 'g' : 'gi';
                const regex = new RegExp(query, flags);
                
                let matchCount = 0;
                const doc = editor.getDoc();
                
                for (let i = 0; i <= editor.lastLine(); i++) {
                    const line = editor.getLine(i);
                    const matches = line.match(regex);
                    if (matches) {
                        matchCount += matches.length;
                        editor.addLineClass(i, "background", "CodeMirror-search-match");
                        searchState.matches.push({
                            line: i,
                            matches: matches
                        });
                    }
                }
                
                updateSearchResults(matchCount);
                
                if (matchCount > 0) {
                    // Move to first match
                    const firstMatch = searchState.matches[0];
                    if (firstMatch.line !== undefined) {
                        editor.setCursor({line: firstMatch.line, ch: 0});
                        editor.scrollIntoView({line: firstMatch.line, ch: 0}, 100);
                        searchState.currentMatchIndex = 0;
                        highlightCurrentMatch(0);
                    }
                }
            } catch (e) {
                updateSearchResults(0, 'خطا در الگوی Regex: ' + e.message);
            }
        }
    }

    function findNext() {
        if (!searchState.query) {
            doSearch();
            return;
        }

        if (searchState.matches.length === 0) {
            doSearch();
            return;
        }

        const caseSensitive = document.getElementById('caseSensitive').checked;
        const useRegex = document.getElementById('useRegex').checked;

        if (!useRegex && searchState.matches.length > 0) {
            // Use SearchCursor for non-regex
            if (!searchState.cursor) {
                searchState.cursor = editor.getSearchCursor(
                    searchState.query,
                    editor.getCursor(),
                    !caseSensitive
                );
            }

            if (searchState.cursor.findNext()) {
                const from = searchState.cursor.from();
                editor.setCursor(from);
                editor.scrollIntoView(from, 100);
                
                // Find match index
                const matchIndex = searchState.matches.findIndex(m => 
                    m.from && m.from.line === from.line && m.from.ch === from.ch
                );
                if (matchIndex >= 0) {
                    searchState.currentMatchIndex = matchIndex;
                    highlightCurrentMatch(matchIndex);
                }
            } else {
                // Wrap around to start
                searchState.cursor = editor.getSearchCursor(
                    searchState.query,
                    {line: 0, ch: 0},
                    !caseSensitive
                );
                if (searchState.cursor.findNext()) {
                    const from = searchState.cursor.from();
                    editor.setCursor(from);
                    editor.scrollIntoView(from, 100);
                    searchState.currentMatchIndex = 0;
                    highlightCurrentMatch(0);
                }
            }
        } else {
            // Regex or simple line-based navigation
            searchState.currentMatchIndex = (searchState.currentMatchIndex + 1) % searchState.matches.length;
            const match = searchState.matches[searchState.currentMatchIndex];
            if (match.line !== undefined) {
                editor.setCursor({line: match.line, ch: 0});
                editor.scrollIntoView({line: match.line, ch: 0}, 100);
                highlightCurrentMatch(searchState.currentMatchIndex);
            }
        }
    }

    function findPrevious() {
        if (!searchState.query) {
            doSearch();
            return;
        }

        if (searchState.matches.length === 0) {
            doSearch();
            return;
        }

        const caseSensitive = document.getElementById('caseSensitive').checked;
        const useRegex = document.getElementById('useRegex').checked;

        if (!useRegex && searchState.matches.length > 0) {
            // Use SearchCursor for non-regex
            if (!searchState.cursor) {
                const cursor = editor.getCursor();
                searchState.cursor = editor.getSearchCursor(
                    searchState.query,
                    {line: cursor.line, ch: cursor.ch - 1},
                    !caseSensitive
                );
            }

            if (searchState.cursor.findPrevious()) {
                const from = searchState.cursor.from();
                editor.setCursor(from);
                editor.scrollIntoView(from, 100);
                
                // Find match index
                const matchIndex = searchState.matches.findIndex(m => 
                    m.from && m.from.line === from.line && m.from.ch === from.ch
                );
                if (matchIndex >= 0) {
                    searchState.currentMatchIndex = matchIndex;
                    highlightCurrentMatch(matchIndex);
                }
            } else {
                // Wrap around to end
                const lastLine = editor.lastLine();
                searchState.cursor = editor.getSearchCursor(
                    searchState.query,
                    {line: lastLine, ch: editor.getLine(lastLine).length},
                    !caseSensitive
                );
                if (searchState.cursor.findPrevious()) {
                    const from = searchState.cursor.from();
                    editor.setCursor(from);
                    editor.scrollIntoView(from, 100);
                    searchState.currentMatchIndex = searchState.matches.length - 1;
                    highlightCurrentMatch(searchState.currentMatchIndex);
                }
            }
        } else {
            // Regex or simple line-based navigation
            searchState.currentMatchIndex = (searchState.currentMatchIndex - 1 + searchState.matches.length) % searchState.matches.length;
            const match = searchState.matches[searchState.currentMatchIndex];
            if (match.line !== undefined) {
                editor.setCursor({line: match.line, ch: 0});
                editor.scrollIntoView({line: match.line, ch: 0}, 100);
                highlightCurrentMatch(searchState.currentMatchIndex);
            }
        }
    }

    function highlightCurrentMatch(index) {
        // Remove previous highlight
        editor.operation(function() {
            for (let i = 0; i < searchState.matches.length; i++) {
                const match = searchState.matches[i];
                if (match.line !== undefined) {
                    editor.removeLineClass(match.line, "background", "CodeMirror-search-match-selected");
                }
            }
        });
        
        // Add highlight to current match
        if (index >= 0 && index < searchState.matches.length) {
            const match = searchState.matches[index];
            if (match.line !== undefined) {
                editor.addLineClass(match.line, "background", "CodeMirror-search-match-selected");
            }
        }
        
        // Update results text
        if (searchState.matches.length > 0) {
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = '<span class="text-success">' + 
                searchState.matches.length + ' مورد یافت شد - مورد ' + 
                (index + 1) + ' از ' + searchState.matches.length + '</span>';
        }
    }

    function clearSearch() {
        searchState.query = null;
        searchState.cursor = null;
        searchState.currentMatchIndex = -1;
        
        editor.operation(function() {
            for (let i = 0; i < searchState.matches.length; i++) {
                const match = searchState.matches[i];
                if (match.line !== undefined) {
                    editor.removeLineClass(match.line, "background", "CodeMirror-search-match");
                    editor.removeLineClass(match.line, "background", "CodeMirror-search-match-selected");
                }
            }
        });
        
        searchState.matches = [];
        document.getElementById('searchInput').value = '';
        document.getElementById('searchResults').textContent = '';
    }

    function updateSearchResults(count, error = null) {
        const resultsDiv = document.getElementById('searchResults');
        if (error) {
            resultsDiv.innerHTML = '<span class="text-danger">' + error + '</span>';
        } else if (count > 0) {
            resultsDiv.innerHTML = '<span class="text-success">' + count + ' مورد یافت شد</span>';
        } else {
            resultsDiv.innerHTML = '<span class="text-muted">موردی یافت نشد</span>';
        }
    }

    // Search on Enter key
    document.getElementById('searchInput').addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            if (e.shiftKey) {
                findPrevious();
            } else {
                findNext();
            }
        } else if (e.key === 'Escape') {
            clearSearch();
            toggleSearch();
        }
    });

    function saveTemplate() {
        const content = editor.getValue();
        const saveBtn = event.target;
        const originalText = saveBtn.innerHTML;
        
        // Show loading
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> در حال ذخیره...';
        
        // Hide previous status
        const statusDiv = document.getElementById('saveStatus');
        statusDiv.style.display = 'none';
        
        // Send request
        fetch('{{ url_for("admin.dashboard_template_save", template_name=template_name) }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ content: content })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                statusDiv.className = 'save-status alert alert-success';
                statusDiv.innerHTML = '<i class="bi bi-check-circle"></i> ' + data.message;
                statusDiv.style.display = 'block';
                
                // Scroll to status
                statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                statusDiv.className = 'save-status alert alert-danger';
                statusDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> ' + data.message;
                statusDiv.style.display = 'block';
            }
        })
        .catch(error => {
            statusDiv.className = 'save-status alert alert-danger';
            statusDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> خطا در ذخیره: ' + error.message;
            statusDiv.style.display = 'block';
        })
        .finally(() => {
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalText;
        });
    }

    function previewTemplate() {
        const content = editor.getValue();
        const previewWindow = window.open('', '_blank');
        previewWindow.document.write(content);
        previewWindow.document.close();
    }

    async function validateCode() {
        const content = editor.getValue();
        const resultsDiv = document.getElementById('validationResults');
        const modal = new bootstrap.Modal(document.getElementById('validationModal'));
        
        // Show loading
        resultsDiv.innerHTML = '<div class="text-center py-5"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">در حال بررسی...</span></div><p class="mt-3">در حال بررسی کدها...</p></div>';
        modal.show();
        
        try {
            const templateName = '{{ template_name|e }}';
            const response = await fetch(`/admin/dashboards/templates/${templateName}/validate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ content: content })
            });
            
            const data = await response.json();
            displayValidationResults(data);
        } catch (error) {
            resultsDiv.innerHTML = `<div class="alert alert-danger"><i class="bi bi-exclamation-circle"></i> خطا در بررسی کدها: ${error.message}</div>`;
        }
    }

    function displayValidationResults(data) {
        const resultsDiv = document.getElementById('validationResults');
        let html = '';
        
        if (data.success) {
            const hasErrors = (data.html_errors && data.html_errors.length > 0) ||
                             (data.css_errors && data.css_errors.length > 0) ||
                             (data.js_errors && data.js_errors.length > 0);
            
            if (!hasErrors) {
                html = '<div class="alert alert-success"><i class="bi bi-check-circle"></i> <strong>عالی!</strong> هیچ مشکلی در کدها یافت نشد.</div>';
            } else {
                html = '<div class="alert alert-warning"><i class="bi bi-exclamation-triangle"></i> <strong>توجه:</strong> برخی مشکلات در کدها شناسایی شد:</div>';
                
                // HTML Errors
                if (data.html_errors && data.html_errors.length > 0) {
                    html += '<div class="mb-4"><h5 class="text-danger"><i class="bi bi-filetype-html"></i> خطاهای HTML (' + data.html_errors.length + ' مورد)</h5>';
                    html += '<div class="list-group">';
                    data.html_errors.forEach((error, index) => {
                        html += `<div class="list-group-item list-group-item-danger">
                            <div class="d-flex w-100 justify-content-between">
                                <h6 class="mb-1">خطا ${index + 1}</h6>
                                ${error.line ? '<small>خط ' + error.line + '</small>' : ''}
                            </div>
                            <p class="mb-1">${escapeHtml(error.message)}</p>
                            ${error.suggestion ? '<div class="mt-2"><strong>پیشنهاد:</strong><pre class="bg-light p-2 rounded mt-1"><code>' + escapeHtml(error.suggestion) + '</code></pre></div>' : ''}
                        </div>`;
                    });
                    html += '</div></div>';
                }
                
                // CSS Errors
                if (data.css_errors && data.css_errors.length > 0) {
                    html += '<div class="mb-4"><h5 class="text-danger"><i class="bi bi-filetype-css"></i> خطاهای CSS (' + data.css_errors.length + ' مورد)</h5>';
                    html += '<div class="list-group">';
                    data.css_errors.forEach((error, index) => {
                        html += `<div class="list-group-item list-group-item-danger">
                            <div class="d-flex w-100 justify-content-between">
                                <h6 class="mb-1">خطا ${index + 1}</h6>
                                ${error.line ? '<small>خط ' + error.line + '</small>' : ''}
                            </div>
                            <p class="mb-1">${escapeHtml(error.message)}</p>
                            ${error.suggestion ? '<div class="mt-2"><strong>پیشنهاد:</strong><pre class="bg-light p-2 rounded mt-1"><code>' + escapeHtml(error.suggestion) + '</code></pre></div>' : ''}
                        </div>`;
                    });
                    html += '</div></div>';
                }
                
                // JS Errors
                if (data.js_errors && data.js_errors.length > 0) {
                    html += '<div class="mb-4"><h5 class="text-danger"><i class="bi bi-filetype-js"></i> خطاهای JavaScript (' + data.js_errors.length + ' مورد)</h5>';
                    html += '<div class="list-group">';
                    data.js_errors.forEach((error, index) => {
                        html += `<div class="list-group-item list-group-item-danger">
                            <div class="d-flex w-100 justify-content-between">
                                <h6 class="mb-1">خطا ${index + 1}</h6>
                                ${error.line ? '<small>خط ' + error.line + '</small>' : ''}
                            </div>
                            <p class="mb-1">${escapeHtml(error.message)}</p>
                            ${error.suggestion ? '<div class="mt-2"><strong>پیشنهاد:</strong><pre class="bg-light p-2 rounded mt-1"><code>' + escapeHtml(error.suggestion) + '</code></pre></div>' : ''}
                        </div>`;
                    });
                    html += '</div></div>';
                }
            }
        } else {
            html = `<div class="alert alert-danger"><i class="bi bi-exclamation-circle"></i> خطا: ${data.message || 'خطای نامشخص'}</div>`;
        }
        
        resultsDiv.innerHTML = html;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Warn before leaving with unsaved changes
    let isDirty = false;
    editor.on('change', function() {
        isDirty = true;
    });

    window.addEventListener('beforeunload', function(e) {
        if (isDirty) {
            e.preventDefault();
            e.returnValue = 'تغییرات ذخیره نشده‌ای دارید. آیا می‌خواهید صفحه را ترک کنید؟';
            return e.returnValue;
        }
    });

    // Reset dirty flag after save
    const originalSave = saveTemplate;
    saveTemplate = function() {
        originalSave();
        setTimeout(() => {
            if (document.getElementById('saveStatus').className.includes('alert-success')) {
                isDirty = false;
            }
        }, 1000);
    };

    // ==================== Visual Chart Editor ====================
    let chartsData = [];
    let tablesData = [];
    let sortableInstance = null;

    // Load visual elements on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadVisualElements();
        
        // Scroll to visual editor if anchor is present
        if (window.location.hash === '#visual-editor') {
            setTimeout(function() {
                const visualEditor = document.getElementById('visual-editor');
                if (visualEditor) {
                    visualEditor.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 500); // Wait a bit for page to fully load
        }
    });

    async function loadVisualElements() {
        const container = document.getElementById('visualElementsContainer');
        if (!container) {
            console.error('visualElementsContainer not found');
            return;
        }
        container.innerHTML = '<div class="text-center py-5"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">در حال بارگذاری...</span></div><p class="mt-3">در حال بارگذاری نمودارها و جداول...</p></div>';
        
        try {
            const templateName = '{{ template_name|e }}';
            const response = await fetch(`/admin/dashboards/templates/${templateName}/charts`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                chartsData = data.charts || [];
                tablesData = data.tables || [];
                
                // Debug: Log color_palette for all charts
                console.log('Loaded charts with color_palette:', chartsData.map(c => ({
                    chart_id: c.chart_id,
                    color_palette: c.color_palette || 'default (not set)'
                })));
                
                // Ensure color_palette is set for all charts
                chartsData.forEach(chart => {
                    if (!chart.color_palette) {
                        chart.color_palette = 'default';
                        console.log(`Set default color_palette for chart: ${chart.chart_id}`);
                    }
                });
                
                // Check if there are any elements
                if (!data.has_elements || (chartsData.length === 0 && tablesData.length === 0)) {
                    container.innerHTML = '<div class="alert alert-info text-center py-5"><i class="bi bi-info-circle"></i> این داشبرد حاوی هیچ نمودار و جدولی نیست.</div>';
                    return;
                }
                
                renderVisualElements();
            } else {
                container.innerHTML = `<div class="alert alert-danger">${data.message || 'خطا در بارگذاری نمودارها و جداول'}</div>`;
            }
        } catch (error) {
            console.error('Error loading visual elements:', error);
            container.innerHTML = `<div class="alert alert-danger">خطا: ${error.message}</div>`;
        }
    }
    
    // Keep old function for backward compatibility
    async function loadCharts() {
        await loadVisualElements();
    }

    function renderVisualElements() {
        const container = document.getElementById('visualElementsContainer');
        
        // Combine charts and tables, sort by display_order
        const allElements = [
            ...chartsData.map(c => ({...c, type: 'chart'})),
            ...tablesData.map(t => ({...t, type: 'table'}))
        ].sort((a, b) => (a.display_order || 0) - (b.display_order || 0));

        if (allElements.length === 0) {
            container.innerHTML = '<div class="alert alert-info text-center py-5"><i class="bi bi-info-circle"></i> این داشبرد حاوی هیچ نمودار و جدولی نیست.</div>';
            return;
        }

        let html = '<div id="visualElementsList">';
        
        allElements.forEach((element, index) => {
            if (element.type === 'chart') {
                html += renderChartElement(element, index);
            } else if (element.type === 'table') {
                html += renderTableElement(element, index);
            }
        });
        
        html += '</div>';
        container.innerHTML = html;

        // Initialize Sortable for drag & drop
        if (sortableInstance) {
            sortableInstance.destroy();
        }
        const elementsList = document.getElementById('visualElementsList');
        if (elementsList) {
            sortableInstance = new Sortable(elementsList, {
                animation: 150,
                handle: '.element-item',
                ghostClass: 'sortable-ghost',
                onEnd: function(evt) {
                    updateAllOrders();
                }
            });
        }

        // Render chart previews
        renderChartPreviews();
    }
    
    function getChartTypeIcon(chartType) {
        const icons = {
            'line': '<i class="bi bi-graph-up"></i>',
            'area': '<i class="bi bi-layers-fill"></i>',
            'bar': '<i class="bi bi-bar-chart"></i>',
            'pie': '<i class="bi bi-pie-chart"></i>',
            'doughnut': '<i class="bi bi-circle"></i>',
            'radar': '<i class="bi bi-radar"></i>',
            'polarArea': '<i class="bi bi-compass"></i>'
        };
        return icons[chartType] || icons['line'];
    }
    
    function renderChartElement(chart, index) {
        const chartType = chart.chart_type || 'line';
        const chartIcon = getChartTypeIcon(chartType);
        
        return `
            <div class="element-item chart-item" data-element-type="chart" data-chart-id="${chart.chart_id}" data-index="${index}">
                <div class="element-header">
                    <span class="element-order-badge">${index + 1}</span>
                    <div class="element-title-wrapper">
                        <span class="chart-type-icon">${chartIcon}</span>
                        <input type="text" class="form-control element-title-input" value="${escapeHtml(chart.title || chart.chart_id)}" 
                               data-chart-id="${chart.chart_id}" onchange="updateChartTitle('${chart.chart_id}', this.value)">
                    </div>
                </div>
                <div class="chart-content-wrapper">
                    <div class="chart-preview" id="preview_${chart.chart_id}">
                        <canvas id="canvas_${chart.chart_id}"></canvas>
                    </div>
                    <div class="element-settings">
                        <div class="chart-settings">
                            <div class="chart-setting-item">
                                <label class="form-check-label">
                                    <input type="checkbox" class="form-check-input" ${chart.is_visible !== false ? 'checked' : ''} 
                                           onchange="updateChartSetting('${chart.chart_id}', 'is_visible', this.checked)">
                                    نمایش نمودار
                                </label>
                            </div>
                            <div class="chart-setting-item">
                                <label class="form-check-label">
                                    <input type="checkbox" class="form-check-input" ${chart.show_labels !== false ? 'checked' : ''} 
                                           onchange="updateChartSetting('${chart.chart_id}', 'show_labels', this.checked)">
                                    نمایش Labelها
                                </label>
                            </div>
                            <div class="chart-setting-item">
                                <label class="form-check-label">
                                    <input type="checkbox" class="form-check-input" ${chart.show_legend !== false ? 'checked' : ''} 
                                           onchange="updateChartSetting('${chart.chart_id}', 'show_legend', this.checked)">
                                    نمایش راهنمای رنگ‌بندی
                                </label>
                            </div>
                            <div class="chart-setting-item">
                                <label class="form-check-label">
                                    <input type="checkbox" class="form-check-input" ${chart.allow_export !== false ? 'checked' : ''} 
                                           onchange="updateChartSetting('${chart.chart_id}', 'allow_export', this.checked)">
                                    امکان خروجی تصویر
                                </label>
                            </div>
                            <div class="chart-setting-item">
                                <label class="form-label">نوع نمودار:</label>
                                <select class="form-select form-select-sm chart-type-select" onchange="updateChartType('${chart.chart_id}', this.value)">
                                    <option value="line" ${(chart.chart_type || 'line') === 'line' ? 'selected' : ''}>خطی</option>
                                    <option value="area" ${chart.chart_type === 'area' ? 'selected' : ''}>مساحت</option>
                                    <option value="bar" ${chart.chart_type === 'bar' ? 'selected' : ''}>ستونی</option>
                                    <option value="pie" ${chart.chart_type === 'pie' ? 'selected' : ''}>دایره‌ای</option>
                                    <option value="doughnut" ${chart.chart_type === 'doughnut' ? 'selected' : ''}>حلقه‌ای</option>
                                    <option value="radar" ${chart.chart_type === 'radar' ? 'selected' : ''}>راداری</option>
                                    <option value="polarArea" ${chart.chart_type === 'polarArea' ? 'selected' : ''}>قطبی</option>
                                </select>
                            </div>
                            <div class="chart-setting-item">
                                <label class="form-label">پالت رنگی:</label>
                                <select class="form-select form-select-sm color-palette-select" 
                                        onchange="updateChartSetting('${chart.chart_id}', 'color_palette', this.value)"
                                        data-chart-id="${chart.chart_id}">
                                    <option value="default" ${(chart.color_palette || 'default') === 'default' ? 'selected' : ''}>پیش‌فرض</option>
                                    <option value="warm" ${chart.color_palette === 'warm' ? 'selected' : ''}>گرم</option>
                                    <option value="cool" ${chart.color_palette === 'cool' ? 'selected' : ''}>سرد</option>
                                    <option value="pastel" ${chart.color_palette === 'pastel' ? 'selected' : ''}>پاستیلی</option>
                                    <option value="formal" ${chart.color_palette === 'formal' ? 'selected' : ''}>رسمی</option>
                                    <option value="vibrant" ${chart.color_palette === 'vibrant' ? 'selected' : ''}>زنده</option>
                                    <option value="ocean" ${chart.color_palette === 'ocean' ? 'selected' : ''}>اقیانوسی</option>
                                </select>
                            </div>
                            <div class="chart-setting-item">
                                <label class="form-label">اولویت نمایش:</label>
                                <input type="number" class="form-control form-control-sm element-order-input" data-chart-id="${chart.chart_id}" 
                                       value="${chart.display_order || index}" min="0" 
                                       onchange="updateChartOrder('${chart.chart_id}', parseInt(this.value))">
                            </div>
                            <div class="chart-setting-item mt-3">
                                <div class="d-flex flex-column gap-2">
                                    <button type="button" class="btn btn-primary btn-sm w-100" 
                                            onclick="saveSingleChart('${chart.chart_id}')">
                                        <i class="bi bi-save"></i> ذخیره این نمودار
                                    </button>
                                    <div class="text-center">
                                        <small class="text-muted d-flex align-items-center justify-content-center gap-1">
                                            <i class="bi bi-tag" style="font-size: 0.7rem;"></i>
                                            <span style="font-size: 0.7rem;">ID:</span>
                                            <code style="font-size: 0.7rem; background: #f8f9fa; padding: 2px 6px; border-radius: 3px; color: #495057;">${chart.chart_id}</code>
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function renderTableElement(table, index) {
        // Build table HTML with actual data
        let tableHtml = '<div class="table-responsive"><table class="table table-striped table-bordered table-sm">';
        
        // Headers
        if (table.headers && table.headers.length > 0) {
            tableHtml += '<thead class="table-dark"><tr>';
            table.headers.forEach(header => {
                tableHtml += `<th>${escapeHtml(header)}</th>`;
            });
            tableHtml += '</tr></thead>';
        }
        
        // Body
        tableHtml += '<tbody>';
        if (table.rows && table.rows.length > 0) {
            table.rows.forEach(row => {
                tableHtml += '<tr>';
                row.forEach(cell => {
                    tableHtml += `<td>${escapeHtml(cell)}</td>`;
                });
                tableHtml += '</tr>';
            });
        } else {
            tableHtml += '<tr><td colspan="' + (table.headers?.length || 1) + '" class="text-center text-muted">هیچ داده‌ای موجود نیست</td></tr>';
        }
        tableHtml += '</tbody></table></div>';
        
        return `
            <div class="element-item table-item" data-element-type="table" data-table-id="${table.table_id}" data-index="${index}">
                <div class="element-header">
                    <span class="element-order-badge">${index + 1}</span>
                    <input type="text" class="form-control element-title-input" value="${escapeHtml(table.title)}" 
                           data-table-id="${table.table_id}" onchange="updateTableTitle('${table.table_id}', this.value)">
                </div>
                <div class="table-preview" id="preview_${table.table_id}">
                    ${tableHtml}
                </div>
                <div class="element-settings">
                    <div class="row g-2">
                        <div class="col-6 col-md-3">
                            <label class="form-check-label">
                                <input type="checkbox" class="form-check-input" ${table.is_visible !== false ? 'checked' : ''} 
                                       onchange="updateTableSetting('${table.table_id}', 'is_visible', this.checked)">
                                نمایش جدول
                            </label>
                        </div>
                        <div class="col-6 col-md-3">
                            <label class="form-check-label">
                                <input type="checkbox" class="form-check-input" ${table.allow_excel_export !== false ? 'checked' : ''} 
                                       onchange="updateTableSetting('${table.table_id}', 'allow_excel_export', this.checked)">
                                امکان خروجی اکسل
                            </label>
                        </div>
                        <div class="col-6 col-md-3">
                            <label>اولویت نمایش:</label>
                            <input type="number" class="form-control form-control-sm element-order-input" data-table-id="${table.table_id}" 
                                   value="${table.display_order || index}" min="0" 
                                   onchange="updateTableOrder('${table.table_id}', parseInt(this.value))">
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function updateAllOrders() {
        const elements = document.querySelectorAll('.element-item');
        elements.forEach((item, index) => {
            const chartId = item.getAttribute('data-chart-id');
            const tableId = item.getAttribute('data-table-id');
            if (chartId) {
                updateChartOrder(chartId, index);
            } else if (tableId) {
                updateTableOrder(tableId, index);
            }
        });
    }
    
    function updateTableTitle(tableId, title) {
        const table = tablesData.find(t => t.table_id === tableId);
        if (table) {
            table.title = title;
        }
    }
    
    function updateTableSetting(tableId, setting, value) {
        const table = tablesData.find(t => t.table_id === tableId);
        if (table) {
            table[setting] = value;
        }
    }
    
    function updateTableOrder(tableId, order) {
        const table = tablesData.find(t => t.table_id === tableId);
        if (table) {
            table.display_order = order;
        }
    }
    
    // Keep old function for backward compatibility
    function renderCharts() {
        renderVisualElements();
    }

    function renderChartPreviews() {
        chartsData.forEach(chart => {
            const canvas = document.getElementById(`canvas_${chart.chart_id}`);
            if (!canvas) {
                console.warn(`Canvas not found for chart: ${chart.chart_id}`);
                return;
            }

            const ctx = canvas.getContext('2d');
            
            // Use actual data from chart_options if available, otherwise use sample data
            const chartOptions = chart.chart_options || {};
            
            // Try to get actual labels and datasets from chart_options
            let labels = chartOptions.sample_labels;
            let datasets = chartOptions.sample_datasets;
            
            // If actual data is available, use it
            if (!labels || !datasets) {
                // Fallback to defaults
                labels = labels || ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد'];
                datasets = datasets || [{
                    label: 'نمونه داده',
                    data: [12, 19, 3, 5, 2],
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }];
            }
            
            // Get color palette for this chart - ensure it's set
            const paletteName = chart.color_palette || 'default';
            const palette = getColorPalette(paletteName);
            
            // Debug log to verify palette is being used
            console.log(`Rendering chart ${chart.chart_id}: palette=${paletteName}, colors=${palette.length}`);
            
            // Prepare datasets - ensure they have proper structure
            const preparedDatasets = datasets.map((ds, idx) => {
                if (typeof ds === 'object' && ds.data) {
                    // Always use palette colors based on color_palette setting
                    // Ignore any existing backgroundColor in ds
                    let bgColor;
                    if (chart.chart_type === 'pie' || chart.chart_type === 'doughnut') {
                        // For pie/doughnut, use array of colors from palette (one color per data point)
                        const dataLength = Array.isArray(ds.data) ? ds.data.length : 0;
                        bgColor = palette.slice(0, dataLength);
                        console.log(`  Dataset ${idx} (${chart.chart_type}): using ${bgColor.length} colors from palette`);
                    } else {
                        // For other chart types (bar, line, etc.), use one color per dataset
                        // Each dataset gets a different color from the palette
                        bgColor = palette[idx % palette.length];
                        console.log(`  Dataset ${idx} (${chart.chart_type}): using color ${bgColor} from palette index ${idx % palette.length}`);
                    }
                    
                    const datasetConfig = {
                        label: ds.label || `داده ${idx + 1}`,
                        data: ds.data,
                        backgroundColor: bgColor, // Always use palette colors, ignore ds.backgroundColor
                        borderColor: ds.borderColor || (chart.chart_type === 'pie' || chart.chart_type === 'doughnut' ? 'rgba(255, 255, 255, 1)' : bgColor),
                        borderWidth: ds.borderWidth || 1
                    };
                    
                    // For area charts, add fill and tension properties
                    if (chart.chart_type === 'area') {
                        datasetConfig.fill = true;
                        datasetConfig.tension = ds.tension || 0.4;
                        // Use a slightly darker border color for area charts
                        if (!ds.borderColor) {
                            datasetConfig.borderColor = bgColor.replace('0.6', '1');
                        }
                    }
                    
                    return datasetConfig;
                } else if (Array.isArray(ds)) {
                    // If it's just an array of numbers
                    let bgColor;
                    if (chart.chart_type === 'pie' || chart.chart_type === 'doughnut') {
                        // For pie/doughnut, use array of colors (one per data point)
                        bgColor = palette.slice(0, ds.length);
                    } else {
                        // For other chart types, use one color per dataset
                        bgColor = palette[idx % palette.length];
                    }
                    
                    const datasetConfig = {
                        label: `داده ${idx + 1}`,
                        data: ds,
                        backgroundColor: bgColor,
                        borderColor: chart.chart_type === 'pie' || chart.chart_type === 'doughnut' ? 'rgba(255, 255, 255, 1)' : bgColor,
                        borderWidth: 1
                    };
                    
                    // For area charts, add fill and tension properties
                    if (chart.chart_type === 'area') {
                        datasetConfig.fill = true;
                        datasetConfig.tension = 0.4;
                        // Use a slightly darker border color for area charts
                        datasetConfig.borderColor = bgColor.replace('0.6', '1');
                    }
                    
                    return datasetConfig;
                }
                return ds;
            });
            
            // Chart data
            const chartData = {
                labels: labels,
                datasets: preparedDatasets
            };

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: chart.title || chart.chart_id
                    },
                    legend: {
                        display: chart.show_legend !== false
                    },
                    datalabels: {
                        display: chart.show_labels !== false
                    }
                }
            };

            // Destroy existing chart if exists
            if (window[`chart_${chart.chart_id}`]) {
                window[`chart_${chart.chart_id}`].destroy();
            }

            // Use chart_type from chart object, fallback to 'line' if not set
            let chartType = chart.chart_type || 'line';
            
            // Area chart is implemented as line chart with fill: true
            let actualChartType = chartType;
            if (chartType === 'area') {
                actualChartType = 'line';
                // Set fill: true for all datasets to make it an area chart
                if (chartData.datasets) {
                    chartData.datasets.forEach(dataset => {
                        dataset.fill = true;
                        dataset.tension = dataset.tension || 0.4;
                    });
                }
            }
            
            window[`chart_${chart.chart_id}`] = new Chart(ctx, {
                type: actualChartType,
                data: chartData,
                options: options
            });
        });
    }

    function updateChartTitle(chartId, title) {
        const chart = chartsData.find(c => c.chart_id === chartId);
        if (chart) {
            chart.title = title;
            // Update preview chart title
            if (window[`chart_${chartId}`]) {
                window[`chart_${chartId}`].options.plugins.title.text = title;
                window[`chart_${chartId}`].update();
            }
        }
    }

    // Color palettes definition (must match server-side)
    const COLOR_PALETTES = {
        'default': [
            'rgba(255, 99, 132, 0.6)',
            'rgba(54, 162, 235, 0.6)',
            'rgba(255, 206, 86, 0.6)',
            'rgba(75, 192, 192, 0.6)',
            'rgba(153, 102, 255, 0.6)',
            'rgba(255, 159, 64, 0.6)',
            'rgba(201, 203, 207, 0.6)'
        ],
        'warm': [
            'rgba(255, 99, 71, 0.6)',
            'rgba(255, 140, 0, 0.6)',
            'rgba(255, 165, 0, 0.6)',
            'rgba(255, 20, 147, 0.6)',
            'rgba(220, 20, 60, 0.6)',
            'rgba(255, 69, 0, 0.6)',
            'rgba(255, 105, 180, 0.6)'
        ],
        'cool': [
            'rgba(70, 130, 180, 0.6)',
            'rgba(100, 149, 237, 0.6)',
            'rgba(65, 105, 225, 0.6)',
            'rgba(30, 144, 255, 0.6)',
            'rgba(0, 191, 255, 0.6)',
            'rgba(72, 209, 204, 0.6)',
            'rgba(32, 178, 170, 0.6)'
        ],
        'pastel': [
            'rgba(255, 182, 193, 0.6)',
            'rgba(255, 218, 185, 0.6)',
            'rgba(221, 160, 221, 0.6)',
            'rgba(176, 224, 230, 0.6)',
            'rgba(175, 238, 238, 0.6)',
            'rgba(144, 238, 144, 0.6)',
            'rgba(255, 228, 196, 0.6)'
        ],
        'formal': [
            'rgba(47, 79, 79, 0.6)',
            'rgba(105, 105, 105, 0.6)',
            'rgba(128, 128, 128, 0.6)',
            'rgba(169, 169, 169, 0.6)',
            'rgba(192, 192, 192, 0.6)',
            'rgba(112, 128, 144, 0.6)',
            'rgba(119, 136, 153, 0.6)'
        ],
        'vibrant': [
            'rgba(255, 0, 0, 0.6)',
            'rgba(0, 255, 0, 0.6)',
            'rgba(0, 0, 255, 0.6)',
            'rgba(255, 255, 0, 0.6)',
            'rgba(255, 0, 255, 0.6)',
            'rgba(0, 255, 255, 0.6)',
            'rgba(255, 128, 0, 0.6)'
        ],
        'ocean': [
            'rgba(0, 119, 190, 0.6)',
            'rgba(0, 150, 255, 0.6)',
            'rgba(64, 224, 208, 0.6)',
            'rgba(0, 206, 209, 0.6)',
            'rgba(72, 209, 204, 0.6)',
            'rgba(95, 158, 160, 0.6)',
            'rgba(176, 196, 222, 0.6)'
        ]
    };
    
    function getColorPalette(paletteName) {
        return COLOR_PALETTES[paletteName] || COLOR_PALETTES['default'];
    }

    function updateChartSetting(chartId, setting, value) {
        const chart = chartsData.find(c => c.chart_id === chartId);
        if (chart) {
            chart[setting] = value;
            // If color_palette changed, update chart immediately
            if (setting === 'color_palette') {
                updateChartColors(chartId, value);
            } else {
                // Update preview for other settings
                renderChartPreviews();
            }
        }
    }
    
    function updateChartColors(chartId, paletteName) {
        const chart = chartsData.find(c => c.chart_id === chartId);
        if (!chart) return;
        
        const palette = getColorPalette(paletteName);
        const chartInstance = window[`chart_${chartId}`];
        
        if (chartInstance && chartInstance.data && chartInstance.data.datasets) {
            // Update colors for all datasets
            chartInstance.data.datasets.forEach((dataset, idx) => {
                if (chart.chart_type === 'pie' || chart.chart_type === 'doughnut') {
                    // For pie/doughnut charts, use array of colors (one color per data point)
                    const dataLength = dataset.data ? dataset.data.length : 0;
                    dataset.backgroundColor = palette.slice(0, dataLength);
                } else {
                    // For other chart types (bar, line, area, etc.), use one color per dataset
                    // Each dataset gets a different color from the palette
                    const newColor = palette[idx % palette.length];
                    dataset.backgroundColor = newColor;
                    // Update borderColor to match backgroundColor for consistency
                    if (dataset.borderColor !== 'rgba(255, 255, 255, 1)') {
                        // For area charts, use a slightly darker border color
                        dataset.borderColor = chart.chart_type === 'area' ? newColor.replace('0.6', '1') : newColor;
                    }
                }
            });
            
            chartInstance.update();
        } else {
            // If chart doesn't exist yet, re-render
            renderChartPreviews();
        }
    }

    function updateChartType(chartId, type) {
        const chart = chartsData.find(c => c.chart_id === chartId);
        if (chart) {
            chart.chart_type = type;
            // Update icon in header
            const chartItem = document.querySelector(`[data-chart-id="${chartId}"]`);
            if (chartItem) {
                const iconWrapper = chartItem.querySelector('.chart-type-icon');
                if (iconWrapper) {
                    iconWrapper.innerHTML = getChartTypeIcon(type);
                }
            }
            // Re-render preview
            renderChartPreviews();
        }
    }

    function updateChartOrder(chartId, order) {
        const chart = chartsData.find(c => c.chart_id === chartId);
        if (chart) {
            chart.display_order = order;
        }
    }

    function updateChartOrders() {
        // This function is called when drag & drop happens
        // It updates display_order based on DOM position
        const items = document.querySelectorAll('.chart-item');
        items.forEach((item, index) => {
            const chartId = item.dataset.chartId;
            const chart = chartsData.find(c => c.chart_id === chartId);
            if (chart) {
                // Update display_order from drag & drop position
                chart.display_order = index;
                // Also update the input field to reflect the new position
                const orderInput = item.querySelector('.chart-order-input');
                if (orderInput) {
                    orderInput.value = index;
                }
            }
            // Update order badge
            const badge = item.querySelector('.chart-order-badge');
            if (badge) {
                badge.textContent = index + 1;
            }
        });
    }

    function updateChartOrderBadges() {
        // Update only the badge numbers without changing display_order values
        // This is used when collecting data to show current visual position
        const items = document.querySelectorAll('.element-item');
        items.forEach((item, index) => {
            const badge = item.querySelector('.element-order-badge');
            if (badge) {
                badge.textContent = index + 1;
            }
        });
    }

    function collectAllChartData() {
        // Collect all chart data from DOM inputs before saving
        console.log('Collecting chart data from DOM...');
        chartsData.forEach(chart => {
            const chartItem = document.querySelector(`[data-chart-id="${chart.chart_id}"]`);
            if (!chartItem) {
                console.warn(`Chart item not found for: ${chart.chart_id}`);
                return;
            }
            
            // Get title from input - use element-title-input for new structure
            const titleInput = chartItem.querySelector('.element-title-input') || chartItem.querySelector('.chart-title-input');
            if (titleInput) {
                const newTitle = titleInput.value.trim();
                if (newTitle) {
                    chart.title = newTitle;
                    console.log(`Updated title for ${chart.chart_id}: ${newTitle}`);
                }
            } else {
                console.warn(`Title input not found for: ${chart.chart_id}`);
            }
            
            // Get display_order from number input - use element-order-input for new structure
            // Priority: Use the value from input field (user's manual change) over drag & drop position
            const orderInput = chartItem.querySelector('.element-order-input') || chartItem.querySelector('.chart-order-input');
            if (orderInput) {
                const orderValue = parseInt(orderInput.value);
                if (!isNaN(orderValue)) {
                    chart.display_order = orderValue;
                    console.log(`Updated display_order for ${chart.chart_id} from input: ${orderValue}`);
                }
            } else {
                // If no input found, use position from drag & drop
                const allElements = document.querySelectorAll('.element-item');
                const elementIndex = Array.from(allElements).indexOf(chartItem);
                if (elementIndex >= 0) {
                    chart.display_order = elementIndex;
                    console.log(`Updated display_order for ${chart.chart_id} from position: ${elementIndex}`);
                } else {
                    console.warn(`Order input not found for: ${chart.chart_id}`);
                }
            }
            
            // Get chart_type from select
            const typeSelect = chartItem.querySelector('.chart-type-select');
            if (typeSelect) {
                chart.chart_type = typeSelect.value || 'line';
                console.log(`Updated chart_type for ${chart.chart_id}: ${chart.chart_type}`);
            } else {
                console.warn(`Type select not found for: ${chart.chart_id}`);
            }
            
            // Get color_palette from select
            const paletteSelect = chartItem.querySelector('.color-palette-select');
            if (paletteSelect) {
                chart.color_palette = paletteSelect.value || 'default';
                console.log(`Updated color_palette for ${chart.chart_id}: ${chart.color_palette}`);
            } else {
                console.warn(`Color palette select not found for: ${chart.chart_id}`);
                // Set default if not found
                chart.color_palette = chart.color_palette || 'default';
            }
            
            // Get show_labels from checkbox - find by onchange attribute
            const allCheckboxes = chartItem.querySelectorAll('input[type="checkbox"]');
            const labelsCheckbox = Array.from(allCheckboxes).find(
                cb => {
                    const onchange = cb.getAttribute('onchange');
                    return onchange && onchange.includes('show_labels');
                }
            );
            if (labelsCheckbox) {
                chart.show_labels = labelsCheckbox.checked;
                console.log(`Updated show_labels for ${chart.chart_id}: ${labelsCheckbox.checked}`);
            } else {
                console.warn(`Labels checkbox not found for: ${chart.chart_id}`);
            }
            
            // Get show_legend from checkbox
            const legendCheckbox = Array.from(allCheckboxes).find(
                cb => {
                    const onchange = cb.getAttribute('onchange');
                    return onchange && onchange.includes('show_legend');
                }
            );
            if (legendCheckbox) {
                chart.show_legend = legendCheckbox.checked;
                console.log(`Updated show_legend for ${chart.chart_id}: ${legendCheckbox.checked}`);
            } else {
                console.warn(`Legend checkbox not found for: ${chart.chart_id}`);
            }
            
            // Get allow_export from checkbox
            const exportCheckbox = Array.from(allCheckboxes).find(
                cb => {
                    const onchange = cb.getAttribute('onchange');
                    return onchange && onchange.includes('allow_export');
                }
            );
            if (exportCheckbox) {
                chart.allow_export = exportCheckbox.checked;
                console.log(`Updated allow_export for ${chart.chart_id}: ${exportCheckbox.checked}`);
            } else {
                console.warn(`Export checkbox not found for: ${chart.chart_id}`);
            }
            
            // Get is_visible from checkbox
            const visibleCheckbox = Array.from(allCheckboxes).find(
                cb => {
                    const onchange = cb.getAttribute('onchange');
                    return onchange && onchange.includes('is_visible');
                }
            );
            if (visibleCheckbox) {
                chart.is_visible = visibleCheckbox.checked;
                console.log(`Updated is_visible for ${chart.chart_id}: ${visibleCheckbox.checked}`);
            }
        });
        
        // Update orders from drag & drop position only if user hasn't manually changed input values
        // This will update the badge numbers but won't override manual input values
        updateChartOrderBadges();
        
        console.log('Final chartsData:', JSON.stringify(chartsData, null, 2));
    }
    
    function collectAllTableData() {
        // Collect all table data from DOM inputs before saving
        console.log('Collecting table data from DOM...');
        tablesData.forEach(table => {
            const tableItem = document.querySelector(`[data-table-id="${table.table_id}"]`);
            if (!tableItem) {
                console.warn(`Table item not found for: ${table.table_id}`);
                return;
            }
            
            // Get title from input
            const titleInput = tableItem.querySelector('.element-title-input');
            if (titleInput) {
                const newTitle = titleInput.value.trim();
                if (newTitle) {
                    table.title = newTitle;
                    console.log(`Updated title for ${table.table_id}: ${newTitle}`);
                }
            }
            
            // Get display_order from number input
            const orderInput = tableItem.querySelector('.element-order-input');
            if (orderInput) {
                const orderValue = parseInt(orderInput.value);
                if (!isNaN(orderValue)) {
                    table.display_order = orderValue;
                    console.log(`Updated display_order for ${table.table_id} from input: ${orderValue}`);
                }
            } else {
                // If no input found, use position from drag & drop
                const allElements = document.querySelectorAll('.element-item');
                const elementIndex = Array.from(allElements).indexOf(tableItem);
                if (elementIndex >= 0) {
                    table.display_order = elementIndex;
                    console.log(`Updated display_order for ${table.table_id} from position: ${elementIndex}`);
                }
            }
            
            // Get checkboxes
            const allCheckboxes = tableItem.querySelectorAll('input[type="checkbox"]');
            const visibleCheckbox = Array.from(allCheckboxes).find(
                cb => {
                    const onchange = cb.getAttribute('onchange');
                    return onchange && onchange.includes('is_visible');
                }
            );
            if (visibleCheckbox) {
                table.is_visible = visibleCheckbox.checked;
            }
            
            const exportCheckbox = Array.from(allCheckboxes).find(
                cb => {
                    const onchange = cb.getAttribute('onchange');
                    return onchange && onchange.includes('allow_excel_export');
                }
            );
            if (exportCheckbox) {
                table.allow_excel_export = exportCheckbox.checked;
            }
        });
        
        console.log('Final tablesData:', JSON.stringify(tablesData, null, 2));
    }

    async function saveChartSettings(event) {
        const statusDiv = document.getElementById('chartSaveStatus');
        const saveBtn = event ? event.target.closest('button') : document.querySelector('button[onclick*="saveChartSettings"]');
        if (!saveBtn) {
            console.error('Save button not found');
            return;
        }
        const originalText = saveBtn.innerHTML;
        
        // Show loading state
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> در حال ذخیره...';
        statusDiv.style.display = 'none';
        
        try {
            // Collect all data from DOM inputs
            collectAllChartData();

            const templateName = '{{ template_name|e }}';
            
            // Log data before sending
            console.log('Sending chart data to server:', JSON.stringify(chartsData, null, 2));
            
            const response = await fetch(`/admin/dashboards/templates/${templateName}/charts`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ charts: chartsData })
            });

            const data = await response.json();
            
            if (data.success) {
                statusDiv.className = 'save-status alert alert-success';
                statusDiv.innerHTML = '<i class="bi bi-check-circle"></i> ' + (data.message || 'تنظیمات با موفقیت ذخیره شد');
                statusDiv.style.display = 'block';
                // Scroll to show the message near the save button
                setTimeout(() => {
                    statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            } else {
                statusDiv.className = 'save-status alert alert-danger';
                statusDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> ' + (data.message || 'خطا در ذخیره تنظیمات');
                statusDiv.style.display = 'block';
                // Scroll to show the message near the save button
                setTimeout(() => {
                    statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
        } catch (error) {
            statusDiv.className = 'save-status alert alert-danger';
            statusDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> خطا در ذخیره: ' + error.message;
            statusDiv.style.display = 'block';
            // Scroll to show the message near the save button
            setTimeout(() => {
                statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        } finally {
            // Restore button state
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalText;
        }
    }
    
    async function saveAllSettings(event) {
        const statusDiv = document.getElementById('chartSaveStatus');
        const saveBtn = event ? event.target.closest('button') : document.querySelector('button[onclick*="saveAllSettings"]');
        if (!saveBtn) {
            console.error('Save button not found');
            return;
        }
        const originalText = saveBtn.innerHTML;
        
        // Show loading state
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> در حال ذخیره...';
        statusDiv.style.display = 'none';
        
        try {
            // Collect all data from DOM inputs
            collectAllChartData();
            collectAllTableData();
            
            // Update display_order from current position in DOM (drag & drop)
            // This ensures that the order reflects the actual visual position after drag & drop
            const allElements = document.querySelectorAll('.element-item');
            allElements.forEach((item, index) => {
                const chartId = item.getAttribute('data-chart-id');
                const tableId = item.getAttribute('data-table-id');
                
                if (chartId) {
                    const chart = chartsData.find(c => c.chart_id === chartId);
                    if (chart) {
                        // Check if user has manually set a value in the input
                        const orderInput = item.querySelector('.element-order-input');
                        if (orderInput && orderInput.value !== '' && !isNaN(parseInt(orderInput.value))) {
                            // User has manually set a value - use it
                            const manualValue = parseInt(orderInput.value);
                            chart.display_order = manualValue;
                            console.log(`Using manual display_order for ${chartId}: ${manualValue}`);
                        } else {
                            // No manual value - use position from drag & drop
                            chart.display_order = index;
                            console.log(`Using drag & drop position for ${chartId}: ${index}`);
                        }
                    }
                } else if (tableId) {
                    const table = tablesData.find(t => t.table_id === tableId);
                    if (table) {
                        const orderInput = item.querySelector('.element-order-input');
                        if (orderInput && orderInput.value !== '' && !isNaN(parseInt(orderInput.value))) {
                            // User has manually set a value - use it
                            const manualValue = parseInt(orderInput.value);
                            table.display_order = manualValue;
                            console.log(`Using manual display_order for ${tableId}: ${manualValue}`);
                        } else {
                            // No manual value - use position from drag & drop
                            table.display_order = index;
                            console.log(`Using drag & drop position for ${tableId}: ${index}`);
                        }
                    }
                }
            });
            
            // Sort charts and tables by display_order before sending
            chartsData.sort((a, b) => (a.display_order || 0) - (b.display_order || 0));
            tablesData.sort((a, b) => (a.display_order || 0) - (b.display_order || 0));
            
            console.log('Final sorted chartsData:', JSON.stringify(chartsData.map(c => ({id: c.chart_id, order: c.display_order, title: c.title})), null, 2));
            console.log('Final sorted tablesData:', JSON.stringify(tablesData.map(t => ({id: t.table_id, order: t.display_order, title: t.title})), null, 2));
            
            const templateName = '{{ template_name|e }}';
            
            // Log data before sending
            console.log('Sending all data to server:');
            console.log('Charts:', JSON.stringify(chartsData, null, 2));
            console.log('Tables:', JSON.stringify(tablesData, null, 2));
            
            const response = await fetch(`/admin/dashboards/templates/${templateName}/save-settings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    charts: chartsData,
                    tables: tablesData
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                statusDiv.className = 'save-status alert alert-success';
                statusDiv.innerHTML = '<i class="bi bi-check-circle"></i> ' + (data.message || 'تمام تنظیمات با موفقیت ذخیره شد');
                statusDiv.style.display = 'block';
                // Scroll to show the message
                setTimeout(() => {
                    statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            } else {
                statusDiv.className = 'save-status alert alert-danger';
                statusDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> ' + (data.message || 'خطا در ذخیره تنظیمات');
                statusDiv.style.display = 'block';
                setTimeout(() => {
                    statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
        } catch (error) {
            console.error('Error saving all settings:', error);
            statusDiv.className = 'save-status alert alert-danger';
            statusDiv.innerHTML = '<i class="bi bi-exclamation-circle"></i> خطا در ذخیره: ' + error.message;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        } finally {
            // Restore button state
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalText;
        }
    }

    // Version management
    async function showVersions() {
        const templateName = '{{ template_name|e }}';
        try {
            const response = await fetch(`/admin/dashboards/templates/${templateName}/versions`);
            const data = await response.json();
            
            if (data.success) {
                displayVersionsModal(data.versions);
            } else {
                alert('خطا در دریافت نسخه‌ها: ' + data.message);
            }
        } catch (error) {
            alert('خطا در دریافت نسخه‌ها: ' + error.message);
        }
    }

    function displayVersionsModal(versions) {
        let modalHtml = `
            <div class="modal fade" id="versionsModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">نسخه‌های قبلی تمپلیت</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>نسخه</th>
                                            <th>تاریخ ایجاد</th>
                                            <th>توضیحات</th>
                                            <th>حجم</th>
                                            <th>عملیات</th>
                                        </tr>
                                    </thead>
                                    <tbody>
        `;
        
        versions.forEach(version => {
            modalHtml += `
                <tr>
                    <td><strong>${version.version_number}</strong></td>
                    <td>${version.created_at_jalali || version.created_at}</td>
                    <td>${version.description || '-'}</td>
                    <td>${(version.content_length / 1024).toFixed(2)} KB</td>
                    <td>
                        <button class="btn btn-sm btn-warning me-1" onclick="restoreVersion(${version.version_number})">
                            <i class="bi bi-arrow-counterclockwise"></i> بازگردانی
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteVersion(${version.version_number})">
                            <i class="bi bi-trash"></i> حذف
                        </button>
                    </td>
                </tr>
            `;
        });
        
        modalHtml += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">بستن</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Remove existing modal if any
        const existingModal = document.getElementById('versionsModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('versionsModal'));
        modal.show();
    }

    // Variables for single chart save
    let pendingChartId = null;
    let pendingChartData = null;
    let pendingDiffData = null;

    async function saveSingleChart(chartId) {
        pendingChartId = chartId;
        
        // Collect data for this specific chart
        const chart = chartsData.find(c => c.chart_id === chartId);
        if (!chart) {
            alert('نمودار یافت نشد');
            return;
        }
        
        // Update chart data from DOM
        const chartItem = document.querySelector(`[data-chart-id="${chartId}"]`);
        if (chartItem) {
            // Update all settings from DOM
            const isVisibleCheckbox = chartItem.querySelector('input[onchange*="is_visible"]');
            if (isVisibleCheckbox) chart.is_visible = isVisibleCheckbox.checked;
            
            const showLabelsCheckbox = chartItem.querySelector('input[onchange*="show_labels"]');
            if (showLabelsCheckbox) chart.show_labels = showLabelsCheckbox.checked;
            
            const showLegendCheckbox = chartItem.querySelector('input[onchange*="show_legend"]');
            if (showLegendCheckbox) chart.show_legend = showLegendCheckbox.checked;
            
            const allowExportCheckbox = chartItem.querySelector('input[onchange*="allow_export"]');
            if (allowExportCheckbox) chart.allow_export = allowExportCheckbox.checked;
            
            const chartTypeSelect = chartItem.querySelector('select[onchange*="updateChartType"]');
            if (chartTypeSelect) chart.chart_type = chartTypeSelect.value;
            
            const colorPaletteSelect = chartItem.querySelector('select.color-palette-select');
            if (colorPaletteSelect) chart.color_palette = colorPaletteSelect.value;
            
            const orderInput = chartItem.querySelector('.element-order-input');
            if (orderInput) chart.display_order = parseInt(orderInput.value) || 0;
        }
        
        pendingChartData = chart;
        
        // Show loading
        const saveBtn = chartItem.querySelector('button[onclick*="saveSingleChart"]');
        const originalText = saveBtn.innerHTML;
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> در حال آماده‌سازی...';
        
        try {
            const templateName = '{{ template_name|e }}';
            
            // Request diff preview
            const response = await fetch(`/admin/dashboards/templates/${templateName}/charts/${chartId}/preview`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ chart: chart })
            });
            
            const data = await response.json();
            
            if (data.success) {
                pendingDiffData = data;
                
                // Display diff in modal
                document.getElementById('diffBeforeCode').textContent = data.before_code || 'کد قبل از تغییر یافت نشد';
                document.getElementById('diffAfterCode').textContent = data.after_code || 'کد بعد از تغییر یافت نشد';
                
                // Update modal title
                document.getElementById('chartDiffModalLabel').innerHTML = 
                    `<i class="bi bi-code-square"></i> پیش‌نمایش تغییرات نمودار: ${chart.title || chartId}`;
                
                // Show modal
                const modal = new bootstrap.Modal(document.getElementById('chartDiffModal'));
                modal.show();
            } else {
                alert('خطا در دریافت پیش‌نمایش: ' + (data.message || 'خطای نامشخص'));
            }
        } catch (error) {
            alert('خطا: ' + error.message);
        } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalText;
        }
    }
    
    async function confirmSaveSingleChart() {
        if (!pendingChartId || !pendingChartData) {
            alert('خطا: اطلاعات نمودار یافت نشد');
            return;
        }
        
        const confirmBtn = document.getElementById('confirmSaveChartBtn');
        const originalText = confirmBtn.innerHTML;
        confirmBtn.disabled = true;
        confirmBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> در حال ذخیره...';
        
        try {
            const templateName = '{{ template_name|e }}';
            
            // Save the chart
            const response = await fetch(`/admin/dashboards/templates/${templateName}/charts/${pendingChartId}/save`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ chart: pendingChartData })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('chartDiffModal'));
                if (modal) {
                    modal.hide();
                }
                
                // Show success message
                const statusDiv = document.getElementById('chartSaveStatus');
                statusDiv.className = 'save-status alert alert-success';
                statusDiv.innerHTML = `<i class="bi bi-check-circle"></i> نمودار "${pendingChartData.title || pendingChartId}" با موفقیت ذخیره شد`;
                statusDiv.style.display = 'block';
                
                // Scroll to status
                setTimeout(() => {
                    statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
                
                // Reload charts to reflect changes
                setTimeout(() => {
                    loadVisualElements();
                }, 1000);
            } else {
                alert('خطا در ذخیره: ' + (data.message || 'خطای نامشخص'));
            }
        } catch (error) {
            alert('خطا: ' + error.message);
        } finally {
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = originalText;
            
            // Clear pending data
            pendingChartId = null;
            pendingChartData = null;
            pendingDiffData = null;
        }
    }

    async function restoreVersion(versionNumber) {
        if (!confirm(`آیا مطمئن هستید که می‌خواهید تمپلیت را به نسخه ${versionNumber} بازگردانید؟\n\nاین عمل یک نسخه پشتیبان از وضعیت فعلی ایجاد می‌کند.`)) {
            return;
        }
        
        const templateName = '{{ template_name|e }}';
        try {
            const response = await fetch(`/admin/dashboards/templates/${templateName}/versions/${versionNumber}/restore`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                alert('تمپلیت با موفقیت بازگردانده شد. لطفاً صفحه را رفرش کنید.');
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('versionsModal'));
                if (modal) {
                    modal.hide();
                }
                // Reload page after 1 second
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            } else {
                alert('خطا در بازگردانی: ' + data.message);
            }
        } catch (error) {
            alert('خطا در بازگردانی: ' + error.message);
        }
    }

    async function deleteVersion(versionNumber) {
        if (!confirm(`آیا مطمئن هستید که می‌خواهید نسخه ${versionNumber} را حذف کنید؟\n\nاین عمل غیرقابل بازگشت است.`)) {
            return;
        }
        
        const templateName = '{{ template_name|e }}';
        try {
            const response = await fetch(`/admin/dashboards/templates/${templateName}/versions/${versionNumber}/delete`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                alert('نسخه با موفقیت حذف شد.');
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('versionsModal'));
                if (modal) {
                    modal.hide();
                }
                // Reload versions list
                setTimeout(() => {
                    showVersions();
                }, 500);
            } else {
                alert('خطا در حذف: ' + data.message);
            }
        } catch (error) {
            alert('خطا در حذف: ' + error.message);
        }
    }
</script>
{% endblock %}

