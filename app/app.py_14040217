import os
import logging
from typing import Any
from urllib.parse import quote_plus
from flask import Flask, redirect, url_for, session, request, render_template
from authlib.integrations.flask_client import OAuth, OAuthError
from functools import wraps
import ssl
import secrets

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('app.log')
    ]
)
logger = logging.getLogger(__name__)

# Initialize Flask app
default_secret = os.getenv('FLASK_SECRET_KEY', None)
if not default_secret:
    # Generate a fallback secret if not provided (not recommended for production)
    default_secret = secrets.token_hex(16)
app = Flask(__name__, template_folder='templates')
app.secret_key = default_secret

# OAuth and SSO settings
SSO_CONFIG = {
    'client_id': os.getenv('SSO_CLIENT_ID', 'bicfu'),
    'client_secret': os.getenv('SSO_CLIENT_SECRET', '5r75G@t39!'),
    'authorize_url': os.getenv('SSO_AUTH_URL', 'https://sso.cfu.ac.ir/oauth2/authorize'),
    'access_token_url': os.getenv('SSO_TOKEN_URL', 'https://sso.cfu.ac.ir/oauth2/token'),
    'userinfo_url': os.getenv('SSO_USERINFO_URL', 'https://sso.cfu.ac.ir/oauth2/userinfo'),
    'scope': os.getenv('SSO_SCOPE', 'openid profile email'),
    'redirect_uri': os.getenv('SSO_REDIRECT_URI', 'https://bi.cfu.ac.ir/authorized')
}

# Paths to SSL certificates (if you uncomment SSL)
SSL_CERT_PATH = 'C:/nginx/certs/cfu.ac.ir-cert.pem'
SSL_KEY_PATH = 'C:/nginx/certs/private.pem'

# Initialize Authlib OAuth
oauth = OAuth(app)
oauth.register(
    name='sso',
    client_id=SSO_CONFIG['client_id'],
    client_secret=SSO_CONFIG['client_secret'],
    authorize_url=SSO_CONFIG['authorize_url'],
    access_token_url=SSO_CONFIG['access_token_url'],
    userinfo_endpoint=SSO_CONFIG['userinfo_url'],
    redirect_uri=SSO_CONFIG['redirect_uri'],
    client_kwargs={
        'scope': SSO_CONFIG['scope'],
        'response_type': 'code'
    }
)

# Utility decorator requiring auth
def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if 'sso_token' not in session:
            logger.info("User not authenticated, redirecting to login")
            return redirect(url_for('login', next=request.path))
        return f(*args, **kwargs)
    return decorated

@app.route('/')
@requires_auth
def index() -> str:
    """Display user information after authentication."""
    try:
        token = session['sso_token']
        user_info = oauth.sso.get(SSO_CONFIG['userinfo_url'], token=token).json()
        logger.info("Fetched user info: %s", user_info)
        return render_template('index.html', user_info=user_info)
    except Exception as e:
        logger.error("Failed to fetch user info: %s", e)
        return render_template('error.html', error="Failed to fetch user information"), 500

@app.route('/login')
def login() -> Any:
    """Initiate SSO authentication with custom state."""
    redirect_uri = SSO_CONFIG['redirect_uri']
    logger.info("Initiating SSO login, redirect_uri: %s, session: %s", redirect_uri, dict(session))

    # 1. Determine where to send the user after SSO
    wants_url = request.args.get('next', url_for('index', _external=True))

    # 2. Generate or retrieve a per-session key and user identifier
    #    This could be a CSRF token or your own session key logic
    sesskey = session.setdefault('sesskey', secrets.token_urlsafe(8))
    user_id = session.setdefault('user_id', 1)  # Replace with your own user/session ID logic

    # 3. Build the inner redirect path expected by CFU SSO
    #    Example: /auth/oauth2/login.php?wantsurl=<encoded>&sesskey=<key>&id=<id>
    inner = (
        f"/auth/oauth2/login.php?"
        f"wantsurl={quote_plus(wants_url)}&"
        f"sesskey={sesskey}&id={user_id}"
    )
    # 4. URL-encode the entire inner string for the state parameter
    state = quote_plus(inner)

    try:
        return oauth.sso.authorize_redirect(
            redirect_uri,
            state=state
        )
    except Exception as e:
        logger.error("Error initiating SSO login: %s", e)
        return render_template('error.html', error="Failed to initiate SSO login"), 500

@app.route('/authorized')
def authorized() -> Any:
    """Handle SSO callback and fetch tokens."""
    logger.info("SSO callback received: %s", request.url)
    try:
        token = oauth.sso.authorize_access_token()
        if not token:
            error = request.args.get('error_description', 'Unknown error')
            logger.error("SSO authorization failed: %s", error)
            return render_template('error.html', error=f"Access denied: {error}"), 400

        # Save token in session
        session['sso_token'] = token
        logger.info("SSO authorization successful, token saved.")
        return redirect(url_for('index'))
    except OAuthError as e:
        logger.error("OAuth error: %s, details: %s", e, e.description)
        return render_template('error.html', error=f"Authorization error: {e.description}"), 400
    except Exception as e:
        logger.error("Unexpected error on authorized: %s", e)
        return render_template('error.html', error="Authorization error"), 500

@app.route('/logout')
def logout() -> Any:
    """Log out the user by clearing the session."""
    session.clear()
    logger.info("User logged out, session cleared.")
    return redirect(url_for('index'))

@app.route('/debug-callback')
def debug_callback() -> str:
    """Debug route to test SSO callback accessibility."""
    logger.info("Debug callback params: %s", request.args)
    return f"Callback received, params: {request.args}" 


def create_ssl_context() -> ssl.SSLContext:
    """Create and configure SSL context (if needed)."""
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=SSL_CERT_PATH, keyfile=SSL_KEY_PATH)
    logger.info("SSL context created successfully")
    return context

if __name__ == '__main__':
    logger.info("Starting Flask app on 0.0.0.0:5000")
    app.run(host='0.0.0.0', port=5000, debug=False)
